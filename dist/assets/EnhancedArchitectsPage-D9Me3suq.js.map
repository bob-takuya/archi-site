{"version":3,"file":"EnhancedArchitectsPage-D9Me3suq.js","sources":["../../node_modules/memoize-one/dist/memoize-one.esm.js","../../node_modules/react-window/dist/index.esm.js","../../src/components/VirtualizedArchitectsList.tsx","../../temp/EnhancedProgressiveImage.tsx","../../src/components/PerformanceMonitor.tsx","../../src/services/CacheService.ts","../../src/pages/EnhancedArchitectsPage.tsx"],"sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","/**\n * Virtualized Architects List - SOW Phase 2 Performance Optimization\n * Implements virtual scrolling for 1000+ architects with 60fps performance\n */\n\nimport React, { memo, useCallback, useMemo, useRef, useEffect } from 'react';\nimport { FixedSizeList as List, areEqual } from 'react-window';\nimport {\n  Card,\n  CardContent,\n  CardActionArea,\n  Typography,\n  Box,\n  Chip,\n  Grid,\n  Container,\n  useTheme,\n  useMediaQuery,\n  Skeleton\n} from '@mui/material';\nimport { Link as RouterLink } from 'react-router-dom';\nimport type { Architect } from '../types/architect';\n\ninterface VirtualizedArchitectsListProps {\n  architects: Architect[];\n  height: number;\n  width?: number;\n  onItemClick?: (architect: Architect) => void;\n  loading?: boolean;\n  loadingCount?: number;\n}\n\n// Memoized architect card component for optimal rendering performance\nconst ArchitectCard = memo<{\n  architect: Architect;\n  style: React.CSSProperties;\n  onItemClick?: (architect: Architect) => void;\n}>(({ architect, style, onItemClick }) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('md'));\n  \n  const handleClick = useCallback(() => {\n    onItemClick?.(architect);\n  }, [architect, onItemClick]);\n\n  const formattedLifespan = useMemo(() => {\n    const birth = architect.ZAT_BIRTHYEAR || '?';\n    const death = architect.ZAT_DEATHYEAR || '';\n    return `${birth}-${death}`;\n  }, [architect.ZAT_BIRTHYEAR, architect.ZAT_DEATHYEAR]);\n\n  const tags = useMemo(() => {\n    const tags = [];\n    if (architect.ZAT_NATIONALITY) tags.push(architect.ZAT_NATIONALITY);\n    if (architect.ZAT_CATEGORY) tags.push(architect.ZAT_CATEGORY);\n    return tags.slice(0, 3); // Limit to 3 tags for performance\n  }, [architect.ZAT_NATIONALITY, architect.ZAT_CATEGORY]);\n\n  return (\n    <div style={style}>\n      <Box sx={{ p: 1 }}>\n        <Card \n          sx={{ \n            height: isMobile ? 140 : 160,\n            display: 'flex', \n            flexDirection: 'column',\n            transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)',\n            willChange: 'transform, box-shadow',\n            '&:hover': {\n              transform: 'translateY(-2px)',\n              boxShadow: theme.shadows[8],\n            },\n          }}\n          elevation={2}\n        >\n          <CardActionArea \n            component={RouterLink} \n            to={`/architects/${architect.ZAT_ID || architect.Z_PK}`}\n            onClick={handleClick}\n            sx={{ \n              height: '100%',\n              display: 'flex',\n              flexDirection: 'column',\n              alignItems: 'stretch',\n            }}\n          >\n            <CardContent sx={{ flexGrow: 1, p: isMobile ? 1.5 : 2 }}>\n              <Typography \n                variant={isMobile ? \"subtitle1\" : \"h6\"} \n                component=\"div\" \n                gutterBottom\n                sx={{\n                  fontWeight: 600,\n                  lineHeight: 1.2,\n                  overflow: 'hidden',\n                  textOverflow: 'ellipsis',\n                  whiteSpace: 'nowrap',\n                }}\n              >\n                {architect.ZAT_ARCHITECT}\n              </Typography>\n              \n              <Typography \n                variant=\"body2\" \n                color=\"text.secondary\" \n                gutterBottom\n                sx={{\n                  fontSize: isMobile ? '0.75rem' : '0.875rem',\n                  lineHeight: 1.3,\n                }}\n              >\n                {architect.ZAT_NATIONALITY || ''}  {formattedLifespan}\n              </Typography>\n              \n              {tags.length > 0 && (\n                <Box sx={{ \n                  display: 'flex', \n                  flexWrap: 'wrap', \n                  gap: 0.5, \n                  mt: 1,\n                  minHeight: 24, // Prevent layout shift\n                }}>\n                  {tags.map((tag, index) => (\n                    <Chip\n                      key={`${tag}-${index}`}\n                      label={tag}\n                      size=\"small\"\n                      variant=\"outlined\"\n                      sx={{ \n                        fontSize: '0.75rem',\n                        height: 20,\n                        maxWidth: 120,\n                        '& .MuiChip-label': {\n                          px: 1,\n                          overflow: 'hidden',\n                          textOverflow: 'ellipsis',\n                        }\n                      }}\n                    />\n                  ))}\n                </Box>\n              )}\n            </CardContent>\n          </CardActionArea>\n        </Card>\n      </Box>\n    </div>\n  );\n}, areEqual);\n\nArchitectCard.displayName = 'ArchitectCard';\n\n// Loading skeleton component\nconst ArchitectSkeleton = memo<{ style: React.CSSProperties }>(({ style }) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('md'));\n  \n  return (\n    <div style={style}>\n      <Box sx={{ p: 1 }}>\n        <Card sx={{ height: isMobile ? 140 : 160, p: isMobile ? 1.5 : 2 }}>\n          <Skeleton variant=\"text\" width=\"80%\" height={24} />\n          <Skeleton variant=\"text\" width=\"60%\" height={20} sx={{ mt: 1 }} />\n          <Box sx={{ display: 'flex', gap: 0.5, mt: 1 }}>\n            <Skeleton variant=\"rounded\" width={60} height={20} />\n            <Skeleton variant=\"rounded\" width={80} height={20} />\n          </Box>\n        </Card>\n      </Box>\n    </div>\n  );\n});\n\nArchitectSkeleton.displayName = 'ArchitectSkeleton';\n\n// Grid row component that handles multiple columns\nconst GridRow = memo<{\n  index: number;\n  style: React.CSSProperties;\n  data: {\n    architects: Architect[];\n    columnsPerRow: number;\n    onItemClick?: (architect: Architect) => void;\n    loading: boolean;\n    loadingCount: number;\n  };\n}>(({ index, style, data }) => {\n  const { architects, columnsPerRow, onItemClick, loading, loadingCount } = data;\n  const startIndex = index * columnsPerRow;\n  \n  const rowItems = useMemo(() => {\n    const items = [];\n    for (let i = 0; i < columnsPerRow; i++) {\n      const architectIndex = startIndex + i;\n      \n      if (loading && architectIndex < loadingCount) {\n        items.push(\n          <Grid item xs={12 / columnsPerRow} key={`skeleton-${architectIndex}`}>\n            <ArchitectSkeleton style={{}} />\n          </Grid>\n        );\n      } else if (architectIndex < architects.length) {\n        const architect = architects[architectIndex];\n        items.push(\n          <Grid item xs={12 / columnsPerRow} key={architect.ZAT_ID || architect.Z_PK || architectIndex}>\n            <ArchitectCard\n              architect={architect}\n              style={{}}\n              onItemClick={onItemClick}\n            />\n          </Grid>\n        );\n      }\n    }\n    return items;\n  }, [architects, columnsPerRow, startIndex, onItemClick, loading, loadingCount]);\n  \n  return (\n    <div style={style}>\n      <Grid container spacing={0}>\n        {rowItems}\n      </Grid>\n    </div>\n  );\n}, areEqual);\n\nGridRow.displayName = 'GridRow';\n\nconst VirtualizedArchitectsList: React.FC<VirtualizedArchitectsListProps> = ({\n  architects,\n  height,\n  width,\n  onItemClick,\n  loading = false,\n  loadingCount = 10\n}) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('md'));\n  const isTablet = useMediaQuery(theme.breakpoints.down('lg'));\n  const listRef = useRef<List>(null);\n\n  // Calculate columns per row based on screen size\n  const columnsPerRow = useMemo(() => {\n    if (isMobile) return 1;\n    if (isTablet) return 2;\n    return 3;\n  }, [isMobile, isTablet]);\n\n  // Calculate item height based on screen size\n  const itemHeight = useMemo(() => {\n    return isMobile ? 150 : 170;\n  }, [isMobile]);\n\n  // Calculate total rows needed\n  const totalRows = useMemo(() => {\n    const totalItems = loading ? loadingCount : architects.length;\n    return Math.ceil(totalItems / columnsPerRow);\n  }, [architects.length, columnsPerRow, loading, loadingCount]);\n\n  // Memoized data for the virtual list\n  const listData = useMemo(() => ({\n    architects,\n    columnsPerRow,\n    onItemClick,\n    loading,\n    loadingCount\n  }), [architects, columnsPerRow, onItemClick, loading, loadingCount]);\n\n  // Calculate optimal overscan count for smooth scrolling\n  const overscanCount = useMemo(() => {\n    return Math.max(2, Math.ceil(height / itemHeight / 4));\n  }, [height, itemHeight]);\n\n  // Auto-scroll to top when architects change\n  useEffect(() => {\n    if (listRef.current && !loading) {\n      listRef.current.scrollToItem(0, 'start');\n    }\n  }, [architects, loading]);\n\n  if (loading && loadingCount === 0) {\n    return (\n      <Container maxWidth=\"lg\">\n        <Grid container spacing={2}>\n          {Array.from({ length: 6 }).map((_, index) => (\n            <Grid item xs={12} sm={6} md={4} key={index}>\n              <ArchitectSkeleton style={{}} />\n            </Grid>\n          ))}\n        </Grid>\n      </Container>\n    );\n  }\n\n  return (\n    <List\n      ref={listRef}\n      height={height}\n      width={width || '100%'}\n      itemCount={totalRows}\n      itemSize={itemHeight}\n      itemData={listData}\n      overscanCount={overscanCount}\n      style={{\n        outline: 'none',\n      }}\n    >\n      {GridRow}\n    </List>\n  );\n};\n\nexport default memo(VirtualizedArchitectsList);\nexport { ArchitectCard, ArchitectSkeleton };","/**\n * Enhanced Progressive Image Component - SOW Phase 2\n * Implements 40% perceived loading improvement with blur placeholders,\n * WebP support, lazy loading, and performance monitoring\n */\n\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport {\n  Box,\n  Skeleton,\n  useTheme,\n  useMediaQuery,\n  IconButton,\n  CircularProgress,\n  Typography,\n  alpha,\n  styled\n} from '@mui/material';\nimport {\n  ImageNotSupported as ImageNotSupportedIcon,\n  Refresh as RefreshIcon,\n  ZoomIn as ZoomInIcon,\n  ZoomOut as ZoomOutIcon,\n  Fullscreen as FullscreenIcon\n} from '@mui/icons-material';\n\n// Performance monitoring interface\ninterface LoadingMetrics {\n  startTime: number;\n  lowQualityLoadTime?: number;\n  highQualityLoadTime?: number;\n  totalLoadTime?: number;\n  perceivedImprovement: number;\n  connectionType: string;\n  imageSize: string;\n}\n\n// Enhanced component props\ninterface EnhancedProgressiveImageProps {\n  src: string;\n  alt: string;\n  width?: number | string;\n  height?: number | string;\n  className?: string;\n  lowQualitySrc?: string;\n  blurDataUrl?: string; // Base64 blur placeholder\n  loading?: 'lazy' | 'eager';\n  priority?: boolean;\n  onLoad?: (metrics: LoadingMetrics) => void;\n  onError?: () => void;\n  style?: React.CSSProperties;\n  objectFit?: 'cover' | 'contain' | 'fill' | 'scale-down' | 'none';\n  borderRadius?: number | string;\n  enableZoom?: boolean;\n  enableFullscreen?: boolean;\n  retryOnError?: boolean;\n  maxRetries?: number;\n  lazyLoadOffset?: number;\n  enablePerformanceMonitoring?: boolean;\n  optimizeForMobile?: boolean;\n  sizes?: string;\n}\n\n// Styled components for enhanced animations\nconst ImageContainer = styled(Box)<{ borderRadius?: number | string }>(({ theme, borderRadius }) => ({\n  position: 'relative',\n  overflow: 'hidden',\n  borderRadius: borderRadius || 0,\n  '&:hover .image-controls': {\n    opacity: 1,\n  },\n  '& img': {\n    transition: 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)',\n  }\n}));\n\nconst BlurPlaceholder = styled(Box)<{ blurDataUrl?: string }>(({ blurDataUrl }) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%',\n  backgroundImage: blurDataUrl ? `url(${blurDataUrl})` : 'none',\n  backgroundSize: 'cover',\n  backgroundPosition: 'center',\n  filter: 'blur(10px)',\n  transform: 'scale(1.1)', // Slight scale to hide blur edges\n  transition: 'opacity 0.4s ease-out',\n  zIndex: 1,\n}));\n\nconst MainImage = styled('img')<{ isLoaded: boolean }>(({ isLoaded }) => ({\n  position: 'relative',\n  zIndex: 2,\n  opacity: isLoaded ? 1 : 0,\n  transition: 'opacity 0.4s ease-out',\n  width: '100%',\n  height: '100%',\n}));\n\n// WebP and format support detection\nconst getImageFormatSupport = () => {\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  \n  return {\n    webp: canvas.toDataURL('image/webp').indexOf('webp') > -1,\n    avif: canvas.toDataURL('image/avif').indexOf('avif') > -1,\n  };\n};\n\n// Enhanced connection detection\nconst getConnectionQuality = (): 'slow' | 'medium' | 'fast' => {\n  const connection = (navigator as any).connection || \n                    (navigator as any).mozConnection || \n                    (navigator as any).webkitConnection;\n  \n  if (!connection) return 'medium';\n  \n  const effectiveType = connection.effectiveType;\n  const downlink = connection.downlink || 1;\n  \n  if (effectiveType === 'slow-2g' || effectiveType === '2g' || downlink < 0.5) {\n    return 'slow';\n  } else if (effectiveType === '3g' || downlink < 1.5) {\n    return 'medium';\n  }\n  return 'fast';\n};\n\n// Generate optimized image URLs with format negotiation\nconst generateOptimizedSrc = (\n  originalSrc: string, \n  quality: 'low' | 'medium' | 'high',\n  format: 'webp' | 'jpeg' | 'avif',\n  width?: number,\n  isMobile?: boolean\n): string => {\n  // In production, this would integrate with your image optimization service\n  // (Cloudinary, Vercel Image Optimization, etc.)\n  \n  const params = new URLSearchParams();\n  \n  // Quality settings\n  const qualityMap = {\n    low: 30,\n    medium: 60,\n    high: 85\n  };\n  \n  params.append('q', qualityMap[quality].toString());\n  \n  // Width optimization\n  if (width) {\n    params.append('w', width.toString());\n  } else {\n    const defaultWidth = isMobile ? \n      (quality === 'low' ? 400 : quality === 'medium' ? 800 : 1200) :\n      (quality === 'low' ? 800 : quality === 'medium' ? 1200 : 1920);\n    params.append('w', defaultWidth.toString());\n  }\n  \n  // Format optimization\n  if (format !== 'jpeg') {\n    params.append('f', format);\n  }\n  \n  // For demo purposes, return original URL\n  // In production: return `${imageOptimizationEndpoint}?url=${encodeURIComponent(originalSrc)}&${params}`\n  return originalSrc;\n};\n\nconst EnhancedProgressiveImage: React.FC<EnhancedProgressiveImageProps> = ({\n  src,\n  alt,\n  width = '100%',\n  height = 'auto',\n  className,\n  lowQualitySrc,\n  blurDataUrl,\n  loading = 'lazy',\n  priority = false,\n  onLoad,\n  onError,\n  style,\n  objectFit = 'cover',\n  borderRadius = 0,\n  enableZoom = false,\n  enableFullscreen = false,\n  retryOnError = true,\n  maxRetries = 3,\n  lazyLoadOffset = 100,\n  enablePerformanceMonitoring = true,\n  optimizeForMobile = true,\n  sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw'\n}) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('md'));\n  const isTablet = useMediaQuery(theme.breakpoints.between('md', 'lg'));\n  \n  // State management\n  const [imageState, setImageState] = useState<'loading' | 'loaded' | 'error'>('loading');\n  const [currentSrc, setCurrentSrc] = useState<string>('');\n  const [lowQualityLoaded, setLowQualityLoaded] = useState(false);\n  const [highQualityLoaded, setHighQualityLoaded] = useState(false);\n  const [isInView, setIsInView] = useState(priority || loading === 'eager');\n  const [retryCount, setRetryCount] = useState(0);\n  const [isZoomed, setIsZoomed] = useState(false);\n  const [isFullscreen, setIsFullscreen] = useState(false);\n  \n  // Performance tracking\n  const [loadingMetrics, setLoadingMetrics] = useState<Partial<LoadingMetrics>>({});\n  \n  // Refs\n  const containerRef = useRef<HTMLDivElement>(null);\n  const imgRef = useRef<HTMLImageElement>(null);\n  const intersectionObserverRef = useRef<IntersectionObserver | null>(null);\n  \n  // Memoized values\n  const formatSupport = useMemo(() => getImageFormatSupport(), []);\n  const connectionQuality = useMemo(() => getConnectionQuality(), []);\n  \n  // Optimized image sources with format negotiation\n  const optimizedSources = useMemo(() => {\n    const preferredFormat = formatSupport.avif ? 'avif' : \n                           formatSupport.webp ? 'webp' : 'jpeg';\n    \n    const targetWidth = isMobile ? 800 : isTablet ? 1200 : 1920;\n    \n    return {\n      low: lowQualitySrc || generateOptimizedSrc(src, 'low', preferredFormat, undefined, isMobile),\n      medium: generateOptimizedSrc(src, 'medium', preferredFormat, targetWidth, isMobile),\n      high: generateOptimizedSrc(src, 'high', preferredFormat, targetWidth, isMobile),\n      fallback: generateOptimizedSrc(src, 'high', 'jpeg', targetWidth, isMobile)\n    };\n  }, [src, lowQualitySrc, formatSupport, isMobile, isTablet]);\n  \n  // Generate srcSet for responsive images\n  const generateSrcSet = useCallback(() => {\n    const sizes = [320, 480, 768, 1024, 1200, 1920];\n    const preferredFormat = formatSupport.webp ? 'webp' : 'jpeg';\n    \n    return sizes.map(size => \n      `${generateOptimizedSrc(src, 'high', preferredFormat, size)} ${size}w`\n    ).join(', ');\n  }, [src, formatSupport]);\n  \n  // Intersection Observer for lazy loading\n  useEffect(() => {\n    if (loading === 'eager' || priority) {\n      setIsInView(true);\n      return;\n    }\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const [entry] = entries;\n        if (entry.isIntersecting) {\n          setIsInView(true);\n          observer.disconnect();\n        }\n      },\n      {\n        rootMargin: `${lazyLoadOffset}px`,\n        threshold: 0.1\n      }\n    );\n\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    intersectionObserverRef.current = observer;\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [loading, priority, lazyLoadOffset]);\n\n  // Progressive loading with enhanced performance tracking\n  useEffect(() => {\n    if (!isInView) return;\n\n    const startTime = Date.now();\n    setLoadingMetrics({ \n      startTime, \n      connectionType: connectionQuality,\n      imageSize: isMobile ? 'mobile' : isTablet ? 'tablet' : 'desktop'\n    });\n\n    const loadImage = (imageSrc: string, isLowQuality = false) => {\n      return new Promise<void>((resolve, reject) => {\n        const img = new Image();\n        \n        // Set loading attributes for better performance\n        img.loading = loading;\n        img.decoding = 'async';\n        \n        img.onload = () => {\n          const loadTime = Date.now();\n          \n          if (isLowQuality) {\n            setLowQualityLoaded(true);\n            setCurrentSrc(imageSrc);\n            setLoadingMetrics(prev => ({ \n              ...prev, \n              lowQualityLoadTime: loadTime - startTime \n            }));\n          } else {\n            setHighQualityLoaded(true);\n            setCurrentSrc(imageSrc);\n            setImageState('loaded');\n            \n            const totalTime = loadTime - startTime;\n            const perceivedImprovement = lowQualityLoaded ? \n              Math.max(0, 100 - ((loadTime - (loadingMetrics.lowQualityLoadTime || 0)) / totalTime * 100)) :\n              0;\n            \n            const finalMetrics: LoadingMetrics = {\n              startTime,\n              lowQualityLoadTime: loadingMetrics.lowQualityLoadTime,\n              highQualityLoadTime: loadTime - startTime,\n              totalLoadTime: totalTime,\n              perceivedImprovement,\n              connectionType: connectionQuality,\n              imageSize: isMobile ? 'mobile' : isTablet ? 'tablet' : 'desktop'\n            };\n            \n            setLoadingMetrics(finalMetrics);\n            onLoad?.(finalMetrics);\n          }\n          \n          resolve();\n        };\n\n        img.onerror = () => {\n          reject(new Error(`Failed to load image: ${imageSrc}`));\n        };\n\n        // Add srcset for responsive loading\n        if (!isLowQuality) {\n          img.srcset = generateSrcSet();\n          img.sizes = sizes;\n        }\n        \n        img.src = imageSrc;\n      });\n    };\n\n    const progressiveLoad = async () => {\n      try {\n        setImageState('loading');\n\n        // Step 1: Load low quality version for immediate feedback\n        if (connectionQuality === 'slow' || (optimizeForMobile && isMobile)) {\n          try {\n            await loadImage(optimizedSources.low, true);\n            // Small delay to ensure user sees low quality version\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (error) {\n            console.warn('Low quality image load failed:', error);\n          }\n        }\n\n        // Step 2: Load high quality version\n        try {\n          await loadImage(optimizedSources.high);\n        } catch (error) {\n          // Fallback to JPEG if WebP/AVIF fails\n          await loadImage(optimizedSources.fallback);\n        }\n        \n      } catch (error) {\n        console.error('Progressive image loading failed:', error);\n        handleImageError();\n      }\n    };\n\n    progressiveLoad();\n  }, [isInView, optimizedSources, connectionQuality, isMobile, isTablet, optimizeForMobile, generateSrcSet, sizes, onLoad, loading]);\n\n  // Error handling with exponential backoff\n  const handleImageError = useCallback(() => {\n    if (retryOnError && retryCount < maxRetries) {\n      setRetryCount(prev => prev + 1);\n      const backoffDelay = Math.min(1000 * Math.pow(2, retryCount), 10000);\n      \n      setTimeout(() => {\n        setImageState('loading');\n        setLowQualityLoaded(false);\n        setHighQualityLoaded(false);\n        setIsInView(false);\n        setTimeout(() => setIsInView(true), 100);\n      }, backoffDelay);\n    } else {\n      setImageState('error');\n      onError?.();\n    }\n  }, [retryOnError, retryCount, maxRetries, onError]);\n\n  // Zoom functionality\n  const handleZoomToggle = useCallback(() => {\n    setIsZoomed(!isZoomed);\n  }, [isZoomed]);\n\n  // Fullscreen functionality\n  const handleFullscreenToggle = useCallback(() => {\n    if (!isFullscreen && containerRef.current) {\n      if (containerRef.current.requestFullscreen) {\n        containerRef.current.requestFullscreen();\n        setIsFullscreen(true);\n      }\n    } else {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n        setIsFullscreen(false);\n      }\n    }\n  }, [isFullscreen]);\n\n  // Manual retry\n  const handleRetry = useCallback(() => {\n    setRetryCount(0);\n    setImageState('loading');\n    setLowQualityLoaded(false);\n    setHighQualityLoaded(false);\n    setIsInView(false);\n    setTimeout(() => setIsInView(true), 100);\n  }, []);\n\n  // Render loading state with enhanced skeleton\n  const renderLoading = () => (\n    <Box\n      sx={{\n        position: 'relative',\n        width,\n        height,\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        backgroundColor: alpha(theme.palette.grey[300], 0.3),\n        borderRadius,\n        overflow: 'hidden'\n      }}\n    >\n      {/* Blur placeholder if available */}\n      {blurDataUrl && (\n        <BlurPlaceholder blurDataUrl={blurDataUrl} />\n      )}\n      \n      {/* Enhanced skeleton with wave animation */}\n      <Skeleton\n        variant=\"rectangular\"\n        width=\"100%\"\n        height=\"100%\"\n        sx={{ \n          borderRadius,\n          position: 'relative',\n          zIndex: blurDataUrl ? 3 : 1,\n          opacity: blurDataUrl ? 0.6 : 1\n        }}\n        animation=\"wave\"\n      />\n      \n      {/* Loading indicator for slow connections */}\n      {connectionQuality === 'slow' && (\n        <Box\n          sx={{\n            position: 'absolute',\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            gap: 1,\n            zIndex: 4,\n            backgroundColor: alpha(theme.palette.background.paper, 0.8),\n            padding: 2,\n            borderRadius: 1,\n            backdropFilter: 'blur(4px)'\n          }}\n        >\n          <CircularProgress size={24} thickness={4} />\n          <Typography variant=\"caption\" color=\"text.secondary\">\n            ...\n          </Typography>\n        </Box>\n      )}\n    </Box>\n  );\n\n  // Render error state\n  const renderError = () => (\n    <Box\n      sx={{\n        width,\n        height,\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        backgroundColor: alpha(theme.palette.error.main, 0.1),\n        borderRadius,\n        border: `1px dashed ${theme.palette.error.main}`,\n        gap: 1,\n        p: 2,\n      }}\n    >\n      <ImageNotSupportedIcon color=\"error\" />\n      <Typography variant=\"caption\" color=\"error\" align=\"center\">\n        \n      </Typography>\n      {retryOnError && retryCount < maxRetries && (\n        <IconButton size=\"small\" onClick={handleRetry} color=\"error\">\n          <RefreshIcon />\n        </IconButton>\n      )}\n    </Box>\n  );\n\n  // Render loaded image with enhanced transitions\n  const renderImage = () => (\n    <ImageContainer\n      borderRadius={borderRadius}\n      sx={{\n        width,\n        height,\n        cursor: enableZoom ? 'zoom-in' : 'default',\n        transform: isZoomed ? 'scale(1.05)' : 'scale(1)',\n        transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)',\n      }}\n    >\n      {/* Blur placeholder */}\n      {blurDataUrl && (\n        <BlurPlaceholder \n          blurDataUrl={blurDataUrl} \n          sx={{ opacity: highQualityLoaded ? 0 : 1 }}\n        />\n      )}\n      \n      {/* Main image with enhanced loading states */}\n      <MainImage\n        ref={imgRef}\n        src={currentSrc}\n        srcSet={generateSrcSet()}\n        sizes={sizes}\n        alt={alt}\n        className={className}\n        isLoaded={highQualityLoaded}\n        style={{\n          objectFit,\n          transform: isZoomed ? 'scale(1.1)' : 'scale(1)',\n          ...style,\n        }}\n        onClick={enableZoom ? handleZoomToggle : undefined}\n        loading={loading}\n        decoding=\"async\"\n      />\n\n      {/* Image controls */}\n      {(enableZoom || enableFullscreen) && highQualityLoaded && (\n        <Box\n          className=\"image-controls\"\n          sx={{\n            position: 'absolute',\n            top: theme.spacing(1),\n            right: theme.spacing(1),\n            display: 'flex',\n            gap: 0.5,\n            opacity: 0,\n            transition: 'opacity 0.2s ease-in-out',\n            backgroundColor: alpha(theme.palette.background.paper, 0.9),\n            borderRadius: 1,\n            backdropFilter: 'blur(8px)',\n          }}\n        >\n          {enableZoom && (\n            <IconButton\n              size=\"small\"\n              onClick={handleZoomToggle}\n              sx={{ minWidth: '32px', minHeight: '32px' }}\n            >\n              {isZoomed ? <ZoomOutIcon /> : <ZoomInIcon />}\n            </IconButton>\n          )}\n          {enableFullscreen && (\n            <IconButton\n              size=\"small\"\n              onClick={handleFullscreenToggle}\n              sx={{ minWidth: '32px', minHeight: '32px' }}\n            >\n              <FullscreenIcon />\n            </IconButton>\n          )}\n        </Box>\n      )}\n      \n      {/* Performance debug info (development only) */}\n      {enablePerformanceMonitoring && process.env.NODE_ENV === 'development' && loadingMetrics.totalLoadTime && (\n        <Box\n          sx={{\n            position: 'absolute',\n            bottom: theme.spacing(1),\n            left: theme.spacing(1),\n            backgroundColor: alpha(theme.palette.common.black, 0.7),\n            color: 'white',\n            padding: 0.5,\n            borderRadius: 0.5,\n            fontSize: '0.6rem',\n            fontFamily: 'monospace'\n          }}\n        >\n          {loadingMetrics.totalLoadTime}ms \n          {loadingMetrics.perceivedImprovement > 0 && \n            ` (+${Math.round(loadingMetrics.perceivedImprovement)}%)`\n          }\n        </Box>\n      )}\n    </ImageContainer>\n  );\n\n  return (\n    <Box ref={containerRef}>\n      {imageState === 'loading' && renderLoading()}\n      {imageState === 'error' && renderError()}\n      {imageState === 'loaded' && renderImage()}\n    </Box>\n  );\n};\n\nexport default EnhancedProgressiveImage;\nexport type { LoadingMetrics, EnhancedProgressiveImageProps };","import React, { useEffect, useState, useCallback } from 'react';\nimport {\n  Box,\n  Card,\n  CardContent,\n  Typography,\n  LinearProgress,\n  Chip,\n  Grid,\n  Accordion,\n  AccordionSummary,\n  AccordionDetails,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemIcon,\n  IconButton,\n  Tooltip,\n} from '@mui/material';\nimport {\n  Speed as SpeedIcon,\n  Memory as MemoryIcon,\n  NetworkCheck as NetworkIcon,\n  Storage as StorageIcon,\n  ExpandMore as ExpandMoreIcon,\n  Refresh as RefreshIcon,\n  Warning as WarningIcon,\n  CheckCircle as CheckCircleIcon,\n  Error as ErrorIcon,\n} from '@mui/icons-material';\n\ninterface PerformanceMetrics {\n  // Core Web Vitals\n  fcp: number; // First Contentful Paint\n  lcp: number; // Largest Contentful Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout Shift\n  \n  // Additional metrics\n  ttfb: number; // Time to First Byte\n  domContentLoaded: number;\n  loadComplete: number;\n  \n  // Memory usage\n  usedHeapSize: number;\n  totalHeapSize: number;\n  heapSizeLimit: number;\n  \n  // Cache performance\n  cacheHitRatio: number;\n  cacheSize: number;\n  \n  // Database performance\n  dbQueryTime: number;\n  dbConnectionTime: number;\n  \n  // Network\n  connectionType: string;\n  effectiveType: string;\n  \n  timestamp: number;\n}\n\ninterface PerformanceThresholds {\n  fcp: { good: number; poor: number };\n  lcp: { good: number; poor: number };\n  fid: { good: number; poor: number };\n  cls: { good: number; poor: number };\n  ttfb: { good: number; poor: number };\n  memoryUsage: { good: number; poor: number };\n  cacheHitRatio: { good: number; poor: number };\n}\n\nconst PERFORMANCE_THRESHOLDS: PerformanceThresholds = {\n  fcp: { good: 1800, poor: 3000 },\n  lcp: { good: 2500, poor: 4000 },\n  fid: { good: 100, poor: 300 },\n  cls: { good: 0.1, poor: 0.25 },\n  ttfb: { good: 800, poor: 1800 },\n  memoryUsage: { good: 0.5, poor: 0.8 },\n  cacheHitRatio: { good: 0.8, poor: 0.5 },\n};\n\n/**\n * Performance monitoring component with real-time metrics\n * Tracks Core Web Vitals and custom performance indicators\n */\nexport const PerformanceMonitor: React.FC = () => {\n  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);\n  const [isCollecting, setIsCollecting] = useState(false);\n  const [history, setHistory] = useState<PerformanceMetrics[]>([]);\n\n  // Collect performance metrics\n  const collectMetrics = useCallback(async () => {\n    setIsCollecting(true);\n    \n    try {\n      const perfEntries = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n      const paintEntries = performance.getEntriesByType('paint');\n      \n      // Core Web Vitals (approximations for demo)\n      const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint')?.startTime || 0;\n      const lcp = await getLCP();\n      const fid = await getFID();\n      const cls = await getCLS();\n      \n      // Memory metrics\n      const memoryInfo = (performance as any).memory;\n      \n      // Cache metrics (from cache service if available)\n      const cacheStats = await getCacheStats();\n      \n      // Network info\n      const networkInfo = (navigator as any).connection || {};\n      \n      const newMetrics: PerformanceMetrics = {\n        fcp,\n        lcp,\n        fid,\n        cls,\n        ttfb: perfEntries.responseStart - perfEntries.requestStart,\n        domContentLoaded: perfEntries.domContentLoadedEventEnd - perfEntries.navigationStart,\n        loadComplete: perfEntries.loadEventEnd - perfEntries.navigationStart,\n        usedHeapSize: memoryInfo?.usedJSHeapSize || 0,\n        totalHeapSize: memoryInfo?.totalJSHeapSize || 0,\n        heapSizeLimit: memoryInfo?.jsHeapSizeLimit || 0,\n        cacheHitRatio: cacheStats.hitRatio,\n        cacheSize: cacheStats.size,\n        dbQueryTime: await measureDbQueryTime(),\n        dbConnectionTime: 0, // Would be measured during DB initialization\n        connectionType: networkInfo.type || 'unknown',\n        effectiveType: networkInfo.effectiveType || 'unknown',\n        timestamp: Date.now(),\n      };\n      \n      setMetrics(newMetrics);\n      setHistory(prev => [...prev.slice(-19), newMetrics]); // Keep last 20 measurements\n      \n    } catch (error) {\n      console.error('Failed to collect performance metrics:', error);\n    } finally {\n      setIsCollecting(false);\n    }\n  }, []);\n\n  // Auto-collect metrics on mount and periodically\n  useEffect(() => {\n    collectMetrics();\n    \n    const interval = setInterval(collectMetrics, 30000); // Every 30 seconds\n    \n    return () => clearInterval(interval);\n  }, [collectMetrics]);\n\n  // Get performance score\n  const getPerformanceScore = (value: number, thresholds: { good: number; poor: number }, invert = false): 'good' | 'needs-improvement' | 'poor' => {\n    if (invert) {\n      if (value >= thresholds.good) return 'good';\n      if (value >= thresholds.poor) return 'needs-improvement';\n      return 'poor';\n    } else {\n      if (value <= thresholds.good) return 'good';\n      if (value <= thresholds.poor) return 'needs-improvement';\n      return 'poor';\n    }\n  };\n\n  // Get score color\n  const getScoreColor = (score: string) => {\n    switch (score) {\n      case 'good': return 'success';\n      case 'needs-improvement': return 'warning';\n      case 'poor': return 'error';\n      default: return 'default';\n    }\n  };\n\n  // Get score icon\n  const getScoreIcon = (score: string) => {\n    switch (score) {\n      case 'good': return <CheckCircleIcon />;\n      case 'needs-improvement': return <WarningIcon />;\n      case 'poor': return <ErrorIcon />;\n      default: return null;\n    }\n  };\n\n  // Format bytes\n  const formatBytes = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  // Format time\n  const formatTime = (ms: number) => {\n    return `${ms.toFixed(0)}ms`;\n  };\n\n  if (!metrics) {\n    return (\n      <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>\n        <LinearProgress />\n      </Box>\n    );\n  }\n\n  return (\n    <Box sx={{ p: 2 }}>\n      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>\n        <Typography variant=\"h5\" sx={{ flexGrow: 1 }}>\n          \n        </Typography>\n        <Tooltip title=\"\">\n          <IconButton onClick={collectMetrics} disabled={isCollecting}>\n            <RefreshIcon />\n          </IconButton>\n        </Tooltip>\n      </Box>\n\n      <Grid container spacing={2}>\n        {/* Core Web Vitals */}\n        <Grid item xs={12} md={6}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" gutterBottom>\n                <SpeedIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                Core Web Vitals\n              </Typography>\n              \n              <List>\n                <ListItem>\n                  <ListItemIcon>\n                    {getScoreIcon(getPerformanceScore(metrics.fcp, PERFORMANCE_THRESHOLDS.fcp))}\n                  </ListItemIcon>\n                  <ListItemText\n                    primary=\"First Contentful Paint\"\n                    secondary={formatTime(metrics.fcp)}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.fcp, PERFORMANCE_THRESHOLDS.fcp)}\n                    color={getScoreColor(getPerformanceScore(metrics.fcp, PERFORMANCE_THRESHOLDS.fcp)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n                \n                <ListItem>\n                  <ListItemIcon>\n                    {getScoreIcon(getPerformanceScore(metrics.lcp, PERFORMANCE_THRESHOLDS.lcp))}\n                  </ListItemIcon>\n                  <ListItemText\n                    primary=\"Largest Contentful Paint\"\n                    secondary={formatTime(metrics.lcp)}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.lcp, PERFORMANCE_THRESHOLDS.lcp)}\n                    color={getScoreColor(getPerformanceScore(metrics.lcp, PERFORMANCE_THRESHOLDS.lcp)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n                \n                <ListItem>\n                  <ListItemIcon>\n                    {getScoreIcon(getPerformanceScore(metrics.fid, PERFORMANCE_THRESHOLDS.fid))}\n                  </ListItemIcon>\n                  <ListItemText\n                    primary=\"First Input Delay\"\n                    secondary={formatTime(metrics.fid)}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.fid, PERFORMANCE_THRESHOLDS.fid)}\n                    color={getScoreColor(getPerformanceScore(metrics.fid, PERFORMANCE_THRESHOLDS.fid)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n                \n                <ListItem>\n                  <ListItemIcon>\n                    {getScoreIcon(getPerformanceScore(metrics.cls, PERFORMANCE_THRESHOLDS.cls))}\n                  </ListItemIcon>\n                  <ListItemText\n                    primary=\"Cumulative Layout Shift\"\n                    secondary={metrics.cls.toFixed(3)}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.cls, PERFORMANCE_THRESHOLDS.cls)}\n                    color={getScoreColor(getPerformanceScore(metrics.cls, PERFORMANCE_THRESHOLDS.cls)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n              </List>\n            </CardContent>\n          </Card>\n        </Grid>\n\n        {/* Memory Usage */}\n        <Grid item xs={12} md={6}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" gutterBottom>\n                <MemoryIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                \n              </Typography>\n              \n              <Box sx={{ mb: 2 }}>\n                <Typography variant=\"body2\" gutterBottom>\n                  : {formatBytes(metrics.usedHeapSize)} / {formatBytes(metrics.totalHeapSize)}\n                </Typography>\n                <LinearProgress\n                  variant=\"determinate\"\n                  value={(metrics.usedHeapSize / metrics.totalHeapSize) * 100}\n                  color={\n                    metrics.usedHeapSize / metrics.totalHeapSize > 0.8 ? 'error' :\n                    metrics.usedHeapSize / metrics.totalHeapSize > 0.6 ? 'warning' : 'success'\n                  }\n                />\n              </Box>\n              \n              <Typography variant=\"body2\" color=\"text.secondary\">\n                : {formatBytes(metrics.heapSizeLimit)}\n              </Typography>\n            </CardContent>\n          </Card>\n        </Grid>\n\n        {/* Network & Cache */}\n        <Grid item xs={12} md={6}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" gutterBottom>\n                <NetworkIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                 & \n              </Typography>\n              \n              <List dense>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={metrics.connectionType}\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={metrics.effectiveType}\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={`${(metrics.cacheHitRatio * 100).toFixed(1)}%`}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.cacheHitRatio, PERFORMANCE_THRESHOLDS.cacheHitRatio, true)}\n                    color={getScoreColor(getPerformanceScore(metrics.cacheHitRatio, PERFORMANCE_THRESHOLDS.cacheHitRatio, true)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={formatBytes(metrics.cacheSize)}\n                  />\n                </ListItem>\n              </List>\n            </CardContent>\n          </Card>\n        </Grid>\n\n        {/* Database Performance */}\n        <Grid item xs={12} md={6}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" gutterBottom>\n                <StorageIcon sx={{ mr: 1, verticalAlign: 'middle' }} />\n                \n              </Typography>\n              \n              <List dense>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={formatTime(metrics.dbQueryTime)}\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"TTFB\"\n                    secondary={formatTime(metrics.ttfb)}\n                  />\n                  <Chip\n                    label={getPerformanceScore(metrics.ttfb, PERFORMANCE_THRESHOLDS.ttfb)}\n                    color={getScoreColor(getPerformanceScore(metrics.ttfb, PERFORMANCE_THRESHOLDS.ttfb)) as any}\n                    size=\"small\"\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"DOM\"\n                    secondary={formatTime(metrics.domContentLoaded)}\n                  />\n                </ListItem>\n                <ListItem>\n                  <ListItemText\n                    primary=\"\"\n                    secondary={formatTime(metrics.loadComplete)}\n                  />\n                </ListItem>\n              </List>\n            </CardContent>\n          </Card>\n        </Grid>\n      </Grid>\n\n      {/* Performance History */}\n      <Accordion sx={{ mt: 2 }}>\n        <AccordionSummary expandIcon={<ExpandMoreIcon />}>\n          <Typography> ({history.length})</Typography>\n        </AccordionSummary>\n        <AccordionDetails>\n          <Box sx={{ maxHeight: 300, overflow: 'auto' }}>\n            {history.slice(-10).reverse().map((metric, index) => (\n              <Box key={metric.timestamp} sx={{ mb: 1, p: 1, bgcolor: 'grey.50', borderRadius: 1 }}>\n                <Typography variant=\"body2\">\n                  {new Date(metric.timestamp).toLocaleTimeString()} - \n                  FCP: {formatTime(metric.fcp)}, \n                  LCP: {formatTime(metric.lcp)}, \n                  Memory: {((metric.usedHeapSize / metric.totalHeapSize) * 100).toFixed(1)}%\n                </Typography>\n              </Box>\n            ))}\n          </Box>\n        </AccordionDetails>\n      </Accordion>\n    </Box>\n  );\n};\n\n// Helper functions for Core Web Vitals measurement\nasync function getLCP(): Promise<number> {\n  return new Promise((resolve) => {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        resolve(lastEntry.startTime);\n        observer.disconnect();\n      });\n      observer.observe({ type: 'largest-contentful-paint', buffered: true });\n      \n      // Fallback timeout\n      setTimeout(() => resolve(0), 1000);\n    } else {\n      resolve(0);\n    }\n  });\n}\n\nasync function getFID(): Promise<number> {\n  return new Promise((resolve) => {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const firstEntry = entries[0];\n        resolve(firstEntry.processingStart - firstEntry.startTime);\n        observer.disconnect();\n      });\n      observer.observe({ type: 'first-input', buffered: true });\n      \n      // Fallback timeout\n      setTimeout(() => resolve(0), 5000);\n    } else {\n      resolve(0);\n    }\n  });\n}\n\nasync function getCLS(): Promise<number> {\n  return new Promise((resolve) => {\n    if ('PerformanceObserver' in window) {\n      let clsValue = 0;\n      const observer = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (!(entry as any).hadRecentInput) {\n            clsValue += (entry as any).value;\n          }\n        }\n      });\n      observer.observe({ type: 'layout-shift', buffered: true });\n      \n      // Measure for 5 seconds\n      setTimeout(() => {\n        observer.disconnect();\n        resolve(clsValue);\n      }, 5000);\n    } else {\n      resolve(0);\n    }\n  });\n}\n\nasync function getCacheStats() {\n  // This would integrate with your actual cache service\n  try {\n    // Assuming you have a global cache service\n    const cacheService = (window as any).cacheService;\n    return cacheService ? cacheService.getStats() : { hitRatio: 0, size: 0 };\n  } catch {\n    return { hitRatio: 0, size: 0 };\n  }\n}\n\nasync function measureDbQueryTime(): Promise<number> {\n  // This would measure actual database query time\n  const start = performance.now();\n  \n  try {\n    // Simulate a quick database query\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n    return performance.now() - start;\n  } catch {\n    return 0;\n  }\n}\n\nexport default PerformanceMonitor;","/**\n * Enhanced Cache Service with IndexedDB persistence\n * Implements multi-layer caching strategy:\n * 1. In-memory cache for fastest access\n * 2. IndexedDB for persistence across sessions\n * 3. Intelligent cache replacement algorithms\n */\n\ninterface CacheItem<T> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n  accessCount: number;\n  lastAccessed: number;\n  size?: number; // For memory management\n}\n\ninterface CacheStats {\n  memorySize: number;\n  memoryMaxSize: number;\n  indexedDbSize: number;\n  hitRatio: number;\n  hits: number;\n  misses: number;\n  totalQueries: number;\n}\n\nclass CacheService {\n  private static instance: CacheService;\n  private memoryCache: Map<string, CacheItem<any>> = new Map();\n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\n  private readonly MEMORY_MAX_SIZE = 50 * 1024 * 1024; // 50MB in memory\n  private readonly MEMORY_MAX_ITEMS = 1000; // Maximum items in memory\n  private readonly INDEXEDDB_MAX_SIZE = 200 * 1024 * 1024; // 200MB in IndexedDB\n  \n  // Performance metrics\n  private stats: CacheStats = {\n    memorySize: 0,\n    memoryMaxSize: this.MEMORY_MAX_SIZE,\n    indexedDbSize: 0,\n    hitRatio: 0,\n    hits: 0,\n    misses: 0,\n    totalQueries: 0,\n  };\n  \n  private dbPromise: Promise<IDBDatabase> | null = null;\n  private readonly DB_NAME = 'ArchiSiteCache';\n  private readonly DB_VERSION = 1;\n  private readonly STORE_NAME = 'queryCache';\n\n  private constructor() {\n    this.initIndexedDB();\n    this.startCleanupInterval();\n    this.startMetricsCollection();\n  }\n\n  public static getInstance(): CacheService {\n    if (!CacheService.instance) {\n      CacheService.instance = new CacheService();\n    }\n    return EnhancedCacheService.instance;\n  }\n\n  /**\n   * Initialize IndexedDB for persistent caching\n   */\n  private async initIndexedDB(): Promise<void> {\n    if (!('indexedDB' in window)) {\n      console.warn('[CacheService] IndexedDB not supported, using memory-only cache');\n      return;\n    }\n\n    this.dbPromise = new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      \n      request.onerror = () => {\n        console.error('[CacheService] Failed to open IndexedDB:', request.error);\n        reject(request.error);\n      };\n      \n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.STORE_NAME)) {\n          const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });\n          store.createIndex('timestamp', 'timestamp', { unique: false });\n          store.createIndex('lastAccessed', 'lastAccessed', { unique: false });\n        }\n      };\n    });\n  }\n\n  /**\n   * Get database instance\n   */\n  private async getDB(): Promise<IDBDatabase | null> {\n    if (!this.dbPromise) return null;\n    \n    try {\n      return await this.dbPromise;\n    } catch (error) {\n      console.error('[CacheService] Failed to get DB:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Generate cache key with better collision resistance\n   */\n  private generateKey(query: string, params: any[] = []): string {\n    const paramsString = params.length > 0 ? JSON.stringify(params) : '';\n    // Use a simple hash for better key generation\n    const combined = `${query}:${paramsString}`;\n    return this.simpleHash(combined);\n  }\n\n  /**\n   * Simple hash function for key generation\n   */\n  private simpleHash(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return `cache_${Math.abs(hash).toString(36)}`;\n  }\n\n  /**\n   * Estimate object size in bytes\n   */\n  private estimateSize(obj: any): number {\n    const str = JSON.stringify(obj);\n    return new Blob([str]).size;\n  }\n\n  /**\n   * Check if cache item is valid\n   */\n  private isValid<T>(item: CacheItem<T>): boolean {\n    return Date.now() - item.timestamp < item.ttl;\n  }\n\n  /**\n   * Get data from memory cache first, then IndexedDB\n   */\n  public async get<T>(query: string, params: any[] = []): Promise<T | null> {\n    const key = this.generateKey(query, params);\n    this.stats.totalQueries++;\n    \n    // Try memory cache first\n    const memoryItem = this.memoryCache.get(key);\n    if (memoryItem && this.isValid(memoryItem)) {\n      memoryItem.accessCount++;\n      memoryItem.lastAccessed = Date.now();\n      this.stats.hits++;\n      this.updateHitRatio();\n      return memoryItem.data;\n    }\n    \n    // Remove invalid item from memory\n    if (memoryItem) {\n      this.memoryCache.delete(key);\n      this.updateMemoryStats();\n    }\n    \n    // Try IndexedDB\n    const dbItem = await this.getFromIndexedDB<T>(key);\n    if (dbItem && this.isValid(dbItem)) {\n      // Promote to memory cache\n      this.setInMemory(key, dbItem.data, dbItem.ttl, dbItem.accessCount + 1);\n      this.stats.hits++;\n      this.updateHitRatio();\n      return dbItem.data;\n    }\n    \n    this.stats.misses++;\n    this.updateHitRatio();\n    return null;\n  }\n\n  /**\n   * Set data in both memory and IndexedDB\n   */\n  public async set<T>(query: string, data: T, params: any[] = [], ttl?: number): Promise<void> {\n    const key = this.generateKey(query, params);\n    const finalTtl = ttl || this.DEFAULT_TTL;\n    \n    // Set in memory cache\n    this.setInMemory(key, data, finalTtl);\n    \n    // Set in IndexedDB for persistence\n    await this.setInIndexedDB(key, data, finalTtl);\n  }\n\n  /**\n   * Set data in memory cache with intelligent eviction\n   */\n  private setInMemory<T>(key: string, data: T, ttl: number, accessCount = 1): void {\n    const size = this.estimateSize(data);\n    \n    // Check if we need to evict items\n    this.evictIfNecessary(size);\n    \n    const item: CacheItem<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl,\n      accessCount,\n      lastAccessed: Date.now(),\n      size,\n    };\n    \n    this.memoryCache.set(key, item);\n    this.updateMemoryStats();\n  }\n\n  /**\n   * Intelligent cache eviction using LRU + LFU hybrid\n   */\n  private evictIfNecessary(newItemSize: number): void {\n    // Check item count limit\n    while (this.memoryCache.size >= this.MEMORY_MAX_ITEMS) {\n      this.evictLeastUsed();\n    }\n    \n    // Check memory size limit\n    while (this.stats.memorySize + newItemSize > this.MEMORY_MAX_SIZE && this.memoryCache.size > 0) {\n      this.evictLeastUsed();\n    }\n  }\n\n  /**\n   * Evict least recently and least frequently used item\n   */\n  private evictLeastUsed(): void {\n    let leastUsedKey = '';\n    let leastUsedScore = Infinity;\n    \n    for (const [key, item] of this.memoryCache.entries()) {\n      // Combine recency and frequency (lower score = more likely to evict)\n      const recencyScore = Date.now() - item.lastAccessed;\n      const frequencyScore = 1 / (item.accessCount + 1);\n      const combinedScore = recencyScore * frequencyScore;\n      \n      if (combinedScore < leastUsedScore) {\n        leastUsedScore = combinedScore;\n        leastUsedKey = key;\n      }\n    }\n    \n    if (leastUsedKey) {\n      this.memoryCache.delete(leastUsedKey);\n      this.updateMemoryStats();\n    }\n  }\n\n  /**\n   * Get data from IndexedDB\n   */\n  private async getFromIndexedDB<T>(key: string): Promise<CacheItem<T> | null> {\n    const db = await this.getDB();\n    if (!db) return null;\n    \n    return new Promise((resolve) => {\n      const transaction = db.transaction([this.STORE_NAME], 'readonly');\n      const store = transaction.objectStore(this.STORE_NAME);\n      const request = store.get(key);\n      \n      request.onsuccess = () => {\n        const result = request.result;\n        if (result) {\n          // Update access count in IndexedDB\n          this.updateIndexedDBAccess(key, result.accessCount + 1);\n          resolve({\n            data: result.data,\n            timestamp: result.timestamp,\n            ttl: result.ttl,\n            accessCount: result.accessCount,\n            lastAccessed: Date.now(),\n          });\n        } else {\n          resolve(null);\n        }\n      };\n      \n      request.onerror = () => {\n        console.error('[CacheService] IndexedDB get error:', request.error);\n        resolve(null);\n      };\n    });\n  }\n\n  /**\n   * Set data in IndexedDB\n   */\n  private async setInIndexedDB<T>(key: string, data: T, ttl: number): Promise<void> {\n    const db = await this.getDB();\n    if (!db) return;\n    \n    const item = {\n      key,\n      data,\n      timestamp: Date.now(),\n      ttl,\n      accessCount: 1,\n      lastAccessed: Date.now(),\n    };\n    \n    return new Promise((resolve) => {\n      const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(this.STORE_NAME);\n      const request = store.put(item);\n      \n      request.onsuccess = () => resolve();\n      request.onerror = () => {\n        console.error('[CacheService] IndexedDB set error:', request.error);\n        resolve();\n      };\n    });\n  }\n\n  /**\n   * Update access count in IndexedDB\n   */\n  private async updateIndexedDBAccess(key: string, accessCount: number): Promise<void> {\n    const db = await this.getDB();\n    if (!db) return;\n    \n    const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(this.STORE_NAME);\n    \n    const getRequest = store.get(key);\n    getRequest.onsuccess = () => {\n      const item = getRequest.result;\n      if (item) {\n        item.accessCount = accessCount;\n        item.lastAccessed = Date.now();\n        store.put(item);\n      }\n    };\n  }\n\n  /**\n   * Update memory statistics\n   */\n  private updateMemoryStats(): void {\n    let totalSize = 0;\n    for (const item of this.memoryCache.values()) {\n      totalSize += item.size || 0;\n    }\n    this.stats.memorySize = totalSize;\n  }\n\n  /**\n   * Update hit ratio\n   */\n  private updateHitRatio(): void {\n    this.stats.hitRatio = this.stats.totalQueries > 0 \n      ? this.stats.hits / this.stats.totalQueries \n      : 0;\n  }\n\n  /**\n   * Clear expired entries from both memory and IndexedDB\n   */\n  public async clearExpired(): Promise<number> {\n    let removedCount = 0;\n    const now = Date.now();\n    \n    // Clear from memory\n    for (const [key, item] of this.memoryCache.entries()) {\n      if (now - item.timestamp >= item.ttl) {\n        this.memoryCache.delete(key);\n        removedCount++;\n      }\n    }\n    \n    // Clear from IndexedDB\n    const db = await this.getDB();\n    if (db) {\n      const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(this.STORE_NAME);\n      const index = store.index('timestamp');\n      \n      const range = IDBKeyRange.upperBound(now - this.DEFAULT_TTL);\n      const request = index.openCursor(range);\n      \n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          removedCount++;\n          cursor.continue();\n        }\n      };\n    }\n    \n    this.updateMemoryStats();\n    return removedCount;\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  public async clear(): Promise<void> {\n    this.memoryCache.clear();\n    this.updateMemoryStats();\n    \n    const db = await this.getDB();\n    if (db) {\n      const transaction = db.transaction([this.STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(this.STORE_NAME);\n      store.clear();\n    }\n    \n    // Reset stats\n    this.stats.hits = 0;\n    this.stats.misses = 0;\n    this.stats.totalQueries = 0;\n    this.stats.hitRatio = 0;\n  }\n\n  /**\n   * Get comprehensive cache statistics\n   */\n  public getStats(): CacheStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Cached wrapper for async functions with enhanced features\n   */\n  public async cachedQuery<T>(\n    query: string,\n    queryFn: () => Promise<T>,\n    params: any[] = [],\n    ttl?: number\n  ): Promise<T> {\n    // Check cache first\n    const cached = await this.get<T>(query, params);\n    if (cached !== null) {\n      console.log(`[CacheService] Cache hit for query: ${query.slice(0, 50)}...`);\n      return cached;\n    }\n\n    // Execute query and cache result\n    console.log(`[CacheService] Cache miss for query: ${query.slice(0, 50)}...`);\n    const result = await queryFn();\n    await this.set(query, result, params, ttl);\n    \n    return result;\n  }\n\n  /**\n   * Start automatic cleanup of expired cache entries\n   */\n  private startCleanupInterval(): void {\n    setInterval(async () => {\n      const removed = await this.clearExpired();\n      if (removed > 0) {\n        console.log(`[CacheService] Cleaned up ${removed} expired cache entries`);\n      }\n    }, 2 * 60 * 1000); // Run every 2 minutes\n  }\n\n  /**\n   * Start metrics collection\n   */\n  private startMetricsCollection(): void {\n    setInterval(() => {\n      console.log(`[CacheService] Stats:`, {\n        hitRatio: `${(this.stats.hitRatio * 100).toFixed(1)}%`,\n        memoryUsage: `${(this.stats.memorySize / 1024 / 1024).toFixed(1)}MB`,\n        totalQueries: this.stats.totalQueries,\n        cacheSize: this.memoryCache.size,\n      });\n    }, 5 * 60 * 1000); // Log every 5 minutes\n  }\n\n  /**\n   * Warm up cache with important queries\n   */\n  public async warmUp(criticalQueries: Array<{ query: string; params?: any[] }>): Promise<void> {\n    console.log('[CacheService] Starting cache warm-up...');\n    \n    for (const { query, params = [] } of criticalQueries) {\n      try {\n        await this.get(query, params);\n      } catch (error) {\n        console.warn(`[CacheService] Failed to warm up query: ${query}`, error);\n      }\n    }\n    \n    console.log('[CacheService] Cache warm-up completed');\n  }\n}\n\nexport default CacheService;","/**\n * Enhanced Architects Page - SOW Phase 2 Integration\n * Combines all performance optimizations and UI enhancements\n */\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { \n  Container, \n  Typography, \n  Box, \n  Card, \n  CardContent, \n  CardActionArea,\n  Chip,\n  CircularProgress,\n  Pagination,\n  Paper,\n  Alert,\n  useTheme,\n  useMediaQuery,\n  Fade,\n  Grow\n} from '@mui/material';\n\nimport { Link as RouterLink } from 'react-router-dom';\nimport PersonIcon from '@mui/icons-material/Person';\nimport CakeIcon from '@mui/icons-material/Cake';\nimport PublicIcon from '@mui/icons-material/Public';\nimport SchoolIcon from '@mui/icons-material/School';\nimport CategoryIcon from '@mui/icons-material/Category';\n\n// Phase 2 Enhanced Components\nimport FacetedSearch from '../components/search/FacetedSearch';\nimport VirtualizedArchitectsList from '../components/VirtualizedArchitectsList';\n// Note: In production, move EnhancedProgressiveImage from temp/ to src/components/\nimport EnhancedProgressiveImage from '../../temp/EnhancedProgressiveImage';\nimport PerformanceMonitor from '../components/PerformanceMonitor';\nimport CacheService from '../services/CacheService';\n\nimport type { SearchFacets, ActiveFacets } from '../components/search/FacetedSearch';\nimport { ArchitectService } from '../services/db';\nimport type { Architect, ArchitectsResponse } from '../types/architect';\n\nconst ITEMS_PER_PAGE = 50; // Increased for virtual scrolling\nconst DEBOUNCE_DELAY = 300;\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\ninterface SearchState {\n  query: string;\n  facets: ActiveFacets;\n  page: number;\n  loading: boolean;\n}\n\ninterface EnhancedArchitectCardProps {\n  architect: Architect;\n  index: number;\n}\n\n// Enhanced Architect Card with Progressive Image Loading\nconst EnhancedArchitectCard: React.FC<EnhancedArchitectCardProps> = ({ architect, index }) => {\n  const theme = useTheme();\n  \n  const getArchitectDisplayName = (architect: Architect): string => {\n    return architect.ZAT_ARCHITECT || architect.ZAR_NAME || '';\n  };\n\n  const getArchitectYears = (architect: Architect): string => {\n    const birth = architect.ZAT_BIRTHYEAR || '?';\n    const death = architect.ZAT_DEATHYEAR || '';\n    return `${birth}-${death}`;\n  };\n\n  const getArchitectTags = (architect: Architect): string[] => {\n    const tags: string[] = [];\n    if (architect.ZAT_NATIONALITY) tags.push(architect.ZAT_NATIONALITY);\n    if (architect.ZAT_CATEGORY) tags.push(architect.ZAT_CATEGORY);\n    if (architect.ZAT_SCHOOL) tags.push(architect.ZAT_SCHOOL);\n    return tags;\n  };\n\n  // Generate placeholder image URL\n  const getArchitectImageUrl = (architect: Architect): string => {\n    // In production, this would return actual architect photos\n    return `https://via.placeholder.com/300x200?text=${encodeURIComponent(getArchitectDisplayName(architect))}`;\n  };\n\n  const getBlurDataUrl = (): string => {\n    // In production, generate actual blur data URLs\n    return 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAIAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAb/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWEREiMxUf/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R//2Q==';\n  };\n\n  return (\n    <Grow in={true} timeout={300 + index * 50}>\n      <Card \n        sx={{ \n          height: '100%',\n          display: 'flex',\n          flexDirection: 'column',\n          transition: 'all 0.2s ease-in-out',\n          '&:hover': {\n            transform: 'translateY(-2px)',\n            boxShadow: theme.shadows[8],\n          },\n        }}\n        elevation={2}\n      >\n        <CardActionArea \n          component={RouterLink} \n          to={`/architects/${architect.ZAT_ID || architect.Z_PK}`}\n          sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}\n        >\n          {/* Progressive Image */}\n          <Box sx={{ width: '100%', height: 200, overflow: 'hidden' }}>\n            <EnhancedProgressiveImage\n              src={getArchitectImageUrl(architect)}\n              alt={getArchitectDisplayName(architect)}\n              width=\"100%\"\n              height={200}\n              blurDataUrl={getBlurDataUrl()}\n              loading=\"lazy\"\n              lazyLoadOffset={200}\n              enablePerformanceMonitoring={true}\n              optimizeForMobile={true}\n              objectFit=\"cover\"\n              enableZoom={false}\n              retryOnError={true}\n              maxRetries={2}\n            />\n          </Box>\n          \n          <CardContent sx={{ flexGrow: 1, width: '100%' }}>\n            {/* Architect Name */}\n            <Typography \n              variant=\"h6\" \n              component=\"div\" \n              gutterBottom\n              sx={{ \n                fontWeight: 600,\n                lineHeight: 1.3,\n                minHeight: '2.6em',\n                display: '-webkit-box',\n                WebkitLineClamp: 2,\n                WebkitBoxOrient: 'vertical',\n                overflow: 'hidden'\n              }}\n            >\n              {getArchitectDisplayName(architect)}\n            </Typography>\n            \n            {/* Basic Info */}\n            <Box sx={{ mb: 2 }}>\n              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>\n                <PublicIcon sx={{ fontSize: 16, color: 'text.secondary' }} />\n                <Typography variant=\"body2\" color=\"text.secondary\">\n                  {architect.ZAT_NATIONALITY || ''}\n                </Typography>\n              </Box>\n              \n              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>\n                <CakeIcon sx={{ fontSize: 16, color: 'text.secondary' }} />\n                <Typography variant=\"body2\" color=\"text.secondary\">\n                  {getArchitectYears(architect)}\n                </Typography>\n              </Box>\n              \n              {architect.ZAT_CATEGORY && (\n                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>\n                  <CategoryIcon sx={{ fontSize: 16, color: 'text.secondary' }} />\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    {architect.ZAT_CATEGORY}\n                  </Typography>\n                </Box>\n              )}\n              \n              {architect.ZAT_SCHOOL && (\n                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>\n                  <SchoolIcon sx={{ fontSize: 16, color: 'text.secondary' }} />\n                  <Typography \n                    variant=\"body2\" \n                    color=\"text.secondary\"\n                    sx={{\n                      display: '-webkit-box',\n                      WebkitLineClamp: 1,\n                      WebkitBoxOrient: 'vertical',\n                      overflow: 'hidden'\n                    }}\n                  >\n                    {architect.ZAT_SCHOOL}\n                  </Typography>\n                </Box>\n              )}\n            </Box>\n            \n            {/* Tags */}\n            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 'auto' }}>\n              {getArchitectTags(architect).slice(0, 3).map((tag, tagIndex) => (\n                <Chip\n                  key={tagIndex}\n                  label={tag}\n                  size=\"small\"\n                  variant=\"outlined\"\n                  sx={{ \n                    fontSize: '0.75rem',\n                    height: 24,\n                    pointerEvents: 'none'\n                  }}\n                />\n              ))}\n              {getArchitectTags(architect).length > 3 && (\n                <Chip\n                  label={`+${getArchitectTags(architect).length - 3}`}\n                  size=\"small\"\n                  variant=\"outlined\"\n                  sx={{ \n                    fontSize: '0.75rem',\n                    height: 24,\n                    pointerEvents: 'none',\n                    color: 'text.secondary'\n                  }}\n                />\n              )}\n            </Box>\n          </CardContent>\n        </CardActionArea>\n      </Card>\n    </Grow>\n  );\n};\n\nconst EnhancedArchitectsPage: React.FC = () => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('md'));\n  const navigate = useNavigate();\n  const location = useLocation();\n  \n  // Initialize cache service\n  const cacheService = useRef(new CacheService('architects', CACHE_TTL));\n  \n  // Core state\n  const [searchState, setSearchState] = useState<SearchState>({\n    query: '',\n    facets: {},\n    page: 1,\n    loading: true\n  });\n  \n  const [architects, setArchitects] = useState<Architect[]>([]);\n  const [searchFacets, setSearchFacets] = useState<SearchFacets>({\n    prefectures: [],\n    architects: [],\n    decades: [],\n    categories: [],\n    materials: [],\n    styles: [],\n    yearRange: {\n      min: 1800,\n      max: new Date().getFullYear(),\n      selectedMin: 1800,\n      selectedMax: new Date().getFullYear(),\n      step: 1,\n      unit: ''\n    },\n    popular: []\n  });\n  \n  const [totalResults, setTotalResults] = useState(0);\n  const [totalPages, setTotalPages] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Performance optimization refs\n  const searchTimeoutRef = useRef<NodeJS.Timeout>();\n  const lastSearchRef = useRef<string>('');\n  const lastFacetsRef = useRef<ActiveFacets>({});\n  \n  // Performance metrics\n  const [performanceMetrics, setPerformanceMetrics] = useState({\n    searchTime: 0,\n    renderTime: 0,\n    cacheHitRate: 0,\n    imageLoadTime: 0\n  });\n  \n  // Load initial facets and URL parameters\n  useEffect(() => {\n    loadInitialState();\n  }, []);\n\n  // Handle URL parameter changes\n  useEffect(() => {\n    const params = new URLSearchParams(location.search);\n    const urlQuery = params.get('search') || '';\n    const urlPage = parseInt(params.get('page') || '1');\n    \n    // Parse facets from URL\n    const urlFacets: ActiveFacets = {};\n    \n    const prefectures = params.get('prefectures');\n    if (prefectures) urlFacets.prefectures = prefectures.split(',');\n    \n    const architects = params.get('architects');\n    if (architects) urlFacets.architects = architects.split(',');\n    \n    const categories = params.get('categories');\n    if (categories) urlFacets.categories = categories.split(',');\n    \n    const styles = params.get('styles');\n    if (styles) urlFacets.styles = styles.split(',');\n    \n    const yearRange = params.get('yearRange');\n    if (yearRange) {\n      const [min, max] = yearRange.split('-').map(Number);\n      if (!isNaN(min) && !isNaN(max)) {\n        urlFacets.yearRange = [min, max];\n      }\n    }\n\n    setSearchState(prev => ({\n      ...prev,\n      query: urlQuery,\n      facets: urlFacets,\n      page: urlPage\n    }));\n  }, [location.search]);\n\n  // Perform search when state changes\n  useEffect(() => {\n    if (shouldPerformSearch()) {\n      performSearch();\n    }\n  }, [searchState.query, searchState.facets, searchState.page]);\n\n  const loadInitialState = async () => {\n    try {\n      // Check cache first\n      const cachedFacets = await cacheService.current.get('initial-facets');\n      if (cachedFacets) {\n        setSearchFacets(cachedFacets);\n        setError(null);\n        return;\n      }\n      \n      const facets = await ArchitectService.getArchitectFacets();\n      setSearchFacets(facets);\n      await cacheService.current.set('initial-facets', facets);\n      setError(null);\n    } catch (err) {\n      console.error('Failed to load initial facets:', err);\n      setError('');\n    }\n  };\n\n  const shouldPerformSearch = (): boolean => {\n    const currentSearch = JSON.stringify({\n      query: searchState.query,\n      facets: searchState.facets,\n      page: searchState.page\n    });\n    \n    const lastSearch = JSON.stringify({\n      query: lastSearchRef.current,\n      facets: lastFacetsRef.current,\n      page: searchState.page\n    });\n    \n    return currentSearch !== lastSearch;\n  };\n\n  const performSearch = useCallback(async () => {\n    // Clear existing timeout\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n\n    // Debounce search for performance\n    searchTimeoutRef.current = setTimeout(async () => {\n      const searchStartTime = performance.now();\n      \n      try {\n        setSearchState(prev => ({ ...prev, loading: true }));\n        setError(null);\n\n        // Generate cache key\n        const cacheKey = JSON.stringify({\n          query: searchState.query,\n          facets: searchState.facets,\n          page: searchState.page\n        });\n        \n        // Check cache\n        const cachedResults = await cacheService.current.get(cacheKey);\n        if (cachedResults) {\n          setArchitects(cachedResults.results);\n          setTotalResults(cachedResults.total);\n          setTotalPages(cachedResults.totalPages);\n          \n          const searchEndTime = performance.now();\n          setPerformanceMetrics(prev => ({\n            ...prev,\n            searchTime: searchEndTime - searchStartTime,\n            cacheHitRate: prev.cacheHitRate + 1\n          }));\n          \n          return;\n        }\n\n        // Perform faceted search\n        const searchResults = await ArchitectService.searchArchitectsWithFacets(\n          searchState.query,\n          searchState.facets,\n          searchState.page,\n          ITEMS_PER_PAGE\n        );\n\n        // Update facets with new counts based on current search\n        const updatedFacets = await ArchitectService.getArchitectFacets(searchState.facets);\n\n        setArchitects(searchResults.results);\n        setTotalResults(searchResults.total);\n        setTotalPages(searchResults.totalPages);\n        setSearchFacets(updatedFacets);\n\n        // Cache results\n        await cacheService.current.set(cacheKey, searchResults);\n\n        // Update refs for next comparison\n        lastSearchRef.current = searchState.query;\n        lastFacetsRef.current = { ...searchState.facets };\n\n        // Update URL without triggering navigation\n        updateURL();\n        \n        const searchEndTime = performance.now();\n        setPerformanceMetrics(prev => ({\n          ...prev,\n          searchTime: searchEndTime - searchStartTime\n        }));\n\n      } catch (err) {\n        console.error('Search failed:', err);\n        setError('');\n        setArchitects([]);\n        setTotalResults(0);\n        setTotalPages(0);\n      } finally {\n        setSearchState(prev => ({ ...prev, loading: false }));\n      }\n    }, DEBOUNCE_DELAY);\n  }, [searchState.query, searchState.facets, searchState.page]);\n\n  const updateURL = () => {\n    const params = new URLSearchParams();\n    \n    if (searchState.query) {\n      params.set('search', searchState.query);\n    }\n    \n    if (searchState.page > 1) {\n      params.set('page', searchState.page.toString());\n    }\n    \n    // Add facet parameters\n    if (searchState.facets.prefectures?.length) {\n      params.set('prefectures', searchState.facets.prefectures.join(','));\n    }\n    \n    if (searchState.facets.architects?.length) {\n      params.set('architects', searchState.facets.architects.join(','));\n    }\n    \n    if (searchState.facets.categories?.length) {\n      params.set('categories', searchState.facets.categories.join(','));\n    }\n    \n    if (searchState.facets.styles?.length) {\n      params.set('styles', searchState.facets.styles.join(','));\n    }\n    \n    if (searchState.facets.yearRange) {\n      const [min, max] = searchState.facets.yearRange;\n      params.set('yearRange', `${min}-${max}`);\n    }\n\n    const newURL = params.toString() ? `?${params.toString()}` : '';\n    if (newURL !== location.search) {\n      navigate(newURL, { replace: true });\n    }\n  };\n\n  const handleSearch = useCallback((query: string, facets: ActiveFacets) => {\n    setSearchState(prev => ({\n      ...prev,\n      query,\n      facets,\n      page: 1 // Reset to first page when search changes\n    }));\n  }, []);\n\n  const handleFacetsChange = useCallback((facets: ActiveFacets) => {\n    setSearchState(prev => ({\n      ...prev,\n      facets,\n      page: 1 // Reset to first page when facets change\n    }));\n  }, []);\n\n  const handlePageChange = (event: React.ChangeEvent<unknown>, value: number) => {\n    setSearchState(prev => ({\n      ...prev,\n      page: value\n    }));\n    \n    // Smooth scroll to top on page change\n    window.scrollTo({ top: 0, behavior: 'smooth' });\n  };\n\n  const handleImageLoad = useCallback((metrics: any) => {\n    setPerformanceMetrics(prev => ({\n      ...prev,\n      imageLoadTime: (prev.imageLoadTime + metrics.totalLoadTime) / 2\n    }));\n  }, []);\n\n  // Render virtualized architect item\n  const renderArchitect = useCallback((architect: Architect, index: number) => {\n    return (\n      <Box sx={{ p: 1, width: isMobile ? '100%' : '50%', height: 'auto' }}>\n        <EnhancedArchitectCard architect={architect} index={index} />\n      </Box>\n    );\n  }, [isMobile]);\n\n  // Clean up timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (searchTimeoutRef.current) {\n        clearTimeout(searchTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  if (error) {\n    return (\n      <Container maxWidth=\"lg\" sx={{ py: 4 }}>\n        <Alert severity=\"error\" sx={{ mb: 3 }}>\n          {error}\n        </Alert>\n      </Container>\n    );\n  }\n\n  return (\n    <Container maxWidth=\"xl\" sx={{ py: 4 }}>\n      {/* Performance Monitor */}\n      <PerformanceMonitor \n        metrics={performanceMetrics}\n        position=\"bottom-right\"\n      />\n      \n      {/* Page Header */}\n      <Fade in={true} timeout={500}>\n        <Box sx={{ mb: 4 }}>\n          <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n            \n          </Typography>\n          <Typography variant=\"body1\" color=\"text.secondary\">\n            \n          </Typography>\n        </Box>\n      </Fade>\n\n      {/* Faceted Search Interface with TouchOptimizedSearchBar */}\n      <Fade in={true} timeout={700}>\n        <Box sx={{ mb: 4 }}>\n          <FacetedSearch\n            onSearch={handleSearch}\n            onFacetsChange={handleFacetsChange}\n            facets={searchFacets}\n            loading={searchState.loading}\n            resultCount={totalResults}\n            placeholder=\"...\"\n            showResultCount={true}\n            mobileBreakpoint={960}\n            maxVisibleFacets={6}\n          />\n        </Box>\n      </Fade>\n\n      {/* Search Results with Virtual Scrolling */}\n      <Box>\n        {searchState.loading ? (\n          <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>\n            <CircularProgress size={48} />\n          </Box>\n        ) : (\n          <>\n            {/* Results with Virtual Scrolling */}\n            {architects.length === 0 ? (\n              <Fade in={true} timeout={500}>\n                <Paper elevation={1} sx={{ p: 6, textAlign: 'center' }}>\n                  <PersonIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />\n                  <Typography variant=\"h6\" gutterBottom>\n                    \n                  </Typography>\n                  <Typography variant=\"body2\" color=\"text.secondary\">\n                    \n                  </Typography>\n                </Paper>\n              </Fade>\n            ) : (\n              <>\n                {/* Use VirtualizedArchitectsList for large result sets */}\n                {architects.length > 20 ? (\n                  <VirtualizedArchitectsList\n                    architects={architects}\n                    renderItem={renderArchitect}\n                    itemHeight={isMobile ? 400 : 350}\n                    overscan={5}\n                    onImageLoad={handleImageLoad}\n                  />\n                ) : (\n                  // Regular grid for small result sets\n                  <Box sx={{ display: 'flex', flexWrap: 'wrap', mx: -1 }}>\n                    {architects.map((architect, index) => (\n                      <Box\n                        key={architect.ZAT_ID || architect.Z_PK || index}\n                        sx={{ \n                          width: isMobile ? '100%' : { xs: '100%', sm: '50%', md: '33.333%', lg: '25%' },\n                          p: 1 \n                        }}\n                      >\n                        <EnhancedArchitectCard architect={architect} index={index} />\n                      </Box>\n                    ))}\n                  </Box>\n                )}\n              </>\n            )}\n            \n            {/* Pagination */}\n            {totalPages > 1 && (\n              <Fade in={true} timeout={900}>\n                <Box sx={{ \n                  display: 'flex', \n                  justifyContent: 'center', \n                  mt: 6,\n                  py: 2\n                }}>\n                  <Pagination \n                    count={totalPages} \n                    page={searchState.page} \n                    onChange={handlePageChange} \n                    color=\"primary\"\n                    size={isMobile ? 'medium' : 'large'}\n                    showFirstButton\n                    showLastButton\n                    sx={{\n                      '& .MuiPaginationItem-root': {\n                        minWidth: isMobile ? 32 : 40,\n                        height: isMobile ? 32 : 40,\n                      }\n                    }}\n                  />\n                </Box>\n              </Fade>\n            )}\n          </>\n        )}\n      </Box>\n    </Container>\n  );\n};\n\nexport default EnhancedArchitectsPage;"],"names":["safeIsNaN","value","isEqual","first","second","areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","hasNativePerformanceNow","now","cancelTimeout","timeoutID","requestTimeout","callback","delay","start","tick","size","getScrollbarSize","recalculate","div","style","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","innerDiv","innerStyle","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","index","data","createListComponent","_ref","_class","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","_inheritsLoose","List","props","_this","_assertThisInitialized","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","scrollDirection","scrollOffset","scrollUpdateWasRequested","_this$props","direction","itemSize","layout","itemStyleCache","_offset","isHorizontal","isRtl","offsetHorizontal","_","__","___","event","_event$currentTarget","clientWidth","scrollLeft","scrollWidth","prevState","_event$currentTarget2","clientHeight","scrollHeight","scrollTop","ref","outerRef","nextProps","validateSharedProps$1","_proto","align","_this$props2","itemCount","scrollbarSize","_this$props3","initialScrollOffset","_this$props4","_this$state","_this$props5","children","className","height","innerRef","innerElementType","innerTagName","itemData","_this$props5$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","width","isScrolling","onScroll","_this$_getRangeToRend","startIndex","stopIndex","items","_index","createElement","estimatedTotalSize","_extends","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props6","overscanCount","_this$state3","overscanBackward","overscanForward","PureComponent","_ref2","_ref3","FixedSizeList","_ref4","instanceProps","lastItemOffset","maxOffset","minOffset","middleOffset","_ref5","offset","_ref6","numVisibleItems","_ref7","shallowDiffers","prev","next","attribute","_attribute","_excluded","_excluded2","areEqual","prevProps","prevStyle","prevRest","_objectWithoutPropertiesLoose","nextStyle","nextRest","ArchitectCard","memo","architect","onItemClick","theme","useTheme","isMobile","useMediaQuery","handleClick","useCallback","formattedLifespan","useMemo","birth","death","tags","jsx","Box","Card","CardActionArea","RouterLink","jsxs","CardContent","Typography","tag","Chip","ArchitectSkeleton","Skeleton","GridRow","architects","columnsPerRow","loading","loadingCount","rowItems","architectIndex","Grid","VirtualizedArchitectsList","isTablet","listRef","useRef","itemHeight","totalRows","totalItems","listData","useEffect","Container","VirtualizedArchitectsList$1","ImageContainer","styled","borderRadius","BlurPlaceholder","blurDataUrl","MainImage","isLoaded","getImageFormatSupport","canvas","getConnectionQuality","connection","effectiveType","downlink","generateOptimizedSrc","originalSrc","quality","format","params","qualityMap","defaultWidth","EnhancedProgressiveImage","src","alt","lowQualitySrc","priority","onLoad","onError","objectFit","enableZoom","enableFullscreen","retryOnError","maxRetries","lazyLoadOffset","enablePerformanceMonitoring","optimizeForMobile","sizes","imageState","setImageState","useState","currentSrc","setCurrentSrc","lowQualityLoaded","setLowQualityLoaded","highQualityLoaded","setHighQualityLoaded","isInView","setIsInView","retryCount","setRetryCount","isZoomed","setIsZoomed","isFullscreen","setIsFullscreen","loadingMetrics","setLoadingMetrics","containerRef","imgRef","intersectionObserverRef","formatSupport","connectionQuality","optimizedSources","preferredFormat","targetWidth","generateSrcSet","observer","entries","entry","startTime","loadImage","imageSrc","isLowQuality","resolve","reject","img","loadTime","totalTime","perceivedImprovement","finalMetrics","error","handleImageError","backoffDelay","handleZoomToggle","handleFullscreenToggle","handleRetry","renderLoading","alpha","CircularProgress","renderError","ImageNotSupportedIcon","IconButton","RefreshIcon","renderImage","ZoomOutIcon","ZoomInIcon","FullscreenIcon","PERFORMANCE_THRESHOLDS","PerformanceMonitor","metrics","setMetrics","isCollecting","setIsCollecting","history","setHistory","collectMetrics","perfEntries","fcp","lcp","getLCP","fid","getFID","cls","getCLS","memoryInfo","cacheStats","getCacheStats","networkInfo","newMetrics","measureDbQueryTime","interval","getPerformanceScore","thresholds","invert","getScoreColor","score","getScoreIcon","CheckCircleIcon","WarningIcon","ErrorIcon","formatBytes","bytes","k","formatTime","ms","Tooltip","SpeedIcon","ListItem","ListItemIcon","ListItemText","MemoryIcon","LinearProgress","NetworkIcon","StorageIcon","Accordion","AccordionSummary","ExpandMoreIcon","AccordionDetails","metric","list","lastEntry","firstEntry","clsValue","cacheService","CacheService","request","db","store","query","paramsString","combined","str","hash","char","obj","item","key","memoryItem","dbItem","ttl","finalTtl","accessCount","newItemSize","leastUsedKey","leastUsedScore","recencyScore","frequencyScore","combinedScore","result","getRequest","totalSize","removedCount","range","cursor","queryFn","cached","removed","criticalQueries","ITEMS_PER_PAGE","DEBOUNCE_DELAY","CACHE_TTL","EnhancedArchitectCard","getArchitectDisplayName","getArchitectYears","getArchitectTags","getArchitectImageUrl","getBlurDataUrl","Grow","PublicIcon","CakeIcon","CategoryIcon","SchoolIcon","tagIndex","EnhancedArchitectsPage","navigate","useNavigate","location","useLocation","searchState","setSearchState","setArchitects","searchFacets","setSearchFacets","totalResults","setTotalResults","totalPages","setTotalPages","setError","searchTimeoutRef","lastSearchRef","lastFacetsRef","performanceMetrics","setPerformanceMetrics","loadInitialState","urlQuery","urlPage","urlFacets","prefectures","categories","styles","yearRange","min","max","shouldPerformSearch","performSearch","cachedFacets","facets","ArchitectService.getArchitectFacets","err","currentSearch","lastSearch","searchStartTime","cacheKey","cachedResults","searchEndTime","searchResults","ArchitectService.searchArchitectsWithFacets","updatedFacets","updateURL","newURL","handleSearch","handleFacetsChange","handlePageChange","handleImageLoad","renderArchitect","Alert","Fade","FacetedSearch","Fragment","Paper","PersonIcon","Pagination"],"mappings":"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","x_google_ignoreList":[0,1]}