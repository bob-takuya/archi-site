// Dynamic imports will be used inside functions

// Determine the base path for assets (always use /archi-site for database files)
const BASE_PATH = '/archi-site';

// Database configuration (will try sql.js-httpvfs first, fallback to direct sql.js)
const DATABASE_CONFIG = {
  from: "jsonconfig",
  configUrl: `${BASE_PATH}/db/database-info.json`
};

// Fallback direct database URL
const DATABASE_URL = `${BASE_PATH}/db/archimap.sqlite`;

// Debug logging
console.log('üîß Environment debug info:');
console.log('  - import.meta.env.PROD:', import.meta.env.PROD);
console.log('  - BASE_PATH:', BASE_PATH);
console.log('  - Database config URL:', DATABASE_CONFIG.configUrl);

// Database instance and initialization state (supports both sql.js-httpvfs and direct sql.js)
let worker: any = null;
let database: any = null;
let isInitializing = false;
let initPromise: Promise<any> | null = null;
let useChunked = true; // Will be set to false if chunked loading fails

/**
 * „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÅÆÁä∂ÊÖã
 */
export enum DatabaseStatus {
  NOT_INITIALIZED = 'not_initialized',
  INITIALIZING = 'initializing',
  READY = 'ready',
  ERROR = 'error',
}

/**
 * „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÅÆÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíËøî„Åô
 */
export const getDatabaseStatus = (): DatabaseStatus => {
  if (worker || database) {
    return DatabaseStatus.READY;
  }
  if (isInitializing) {
    return DatabaseStatus.INITIALIZING;
  }
  return DatabaseStatus.NOT_INITIALIZED;
};

/**
 * Connection speed detection for better error messages
 */
const detectConnectionSpeed = async (): Promise<'fast' | 'slow' | 'very-slow'> => {
  try {
    const startTime = Date.now();
    const response = await fetch(`${BASE_PATH}/images/shinkenchiku-favicon.ico`, { 
      method: 'HEAD',
      cache: 'no-cache'
    });
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    if (duration < 100) return 'fast';
    if (duration < 500) return 'slow';
    return 'very-slow';
  } catch {
    return 'very-slow';
  }
};

/**
 * Try chunked database loading with sql.js-httpvfs
 */
async function tryChunkedLoading(): Promise<any> {
  console.log('üöÄ Attempting chunked database loading with sql.js-httpvfs...');
  
  // FIX: Skip chunked loading for architects page due to bundling issue
  if (window.location.hash.includes('/architects')) {
    console.warn('‚ö†Ô∏è Skipping chunked loading for architects page due to known bundling issue');
    throw new Error('Chunked loading disabled for architects page');
  }
  
  try {
    // Dynamic import of sql.js-httpvfs
    // FIX: Add error handling for module import
    let createDbWorker;
    try {
      const module = await import('sql.js-httpvfs');
      createDbWorker = module.createDbWorker;
      
      // FIX: Verify the function exists and is not minified incorrectly
      if (typeof createDbWorker !== 'function') {
        console.error('createDbWorker is not a function, module keys:', Object.keys(module));
        throw new Error('sql.js-httpvfs module loaded but createDbWorker is not a function');
      }
    } catch (importError) {
      console.error('Failed to import sql.js-httpvfs:', importError);
      throw new Error(`Module import failed: ${importError.message}`);
    }
    
    // Test database config file accessibility
    console.log('üóÑÔ∏è Testing database config file accessibility...');
    console.log(`üîó Config URL: ${DATABASE_CONFIG.configUrl}`);
    const configResponse = await fetch(DATABASE_CONFIG.configUrl, { method: 'HEAD' });
    
    if (!configResponse.ok) {
      throw new Error(`Database config not accessible: ${configResponse.status} ${configResponse.statusText}`);
    }
    
    console.log('‚úÖ Database config is accessible');
    
    // Create worker with proper configuration for GitHub Pages
    const workerUrl = new URL(`${BASE_PATH}/sqlite.worker.js`, window.location.origin);
    const wasmUrl = new URL(`${BASE_PATH}/sql-wasm.wasm`, window.location.origin);
    
    console.log('üîß Worker URL:', workerUrl.toString());
    console.log('üîß WASM URL:', wasmUrl.toString());
    
    // Use proper inline configuration format for sql.js-httpvfs
    const dbConfig = [{
      from: "inline",
      config: {
        serverMode: "full",
        url: `${BASE_PATH}/db/archimap.sqlite`,
        requestChunkSize: 65536
      },
      // Add fileLength at top level to help with GitHub Pages compression issues
      fileLength: 12730368
    }];
    
    console.log('üîß Using inline config:', JSON.stringify(dbConfig, null, 2));
    
    // Initialize sql.js-httpvfs worker with proper configuration format
    // FIX: Add try-catch specifically for createDbWorker call
    try {
      worker = await createDbWorker(dbConfig, workerUrl.toString(), wasmUrl.toString());
    } catch (workerError) {
      console.error('createDbWorker failed:', workerError);
      // Check for the specific "ge is not a function" error
      if (workerError.message && workerError.message.includes('is not a function')) {
        throw new Error('Bundling issue detected: minified function name conflict');
      }
      throw workerError;
    }
    
    console.log('‚úÖ sql.js-httpvfs worker initialized successfully');
    
    // Test database functionality
    const versionResult = await worker.db.exec('SELECT sqlite_version()');
    if (versionResult && versionResult.length > 0) {
      console.log(`üîç SQLite „Éê„Éº„Ç∏„Éß„É≥: ${versionResult[0].values[0][0]}`);
    }
    
    const tablesResult = await worker.db.exec("SELECT name FROM sqlite_master WHERE type='table'");
    if (tablesResult && tablesResult.length > 0) {
      console.log(`üìã Âà©Áî®ÂèØËÉΩ„Å™„ÉÜ„Éº„Éñ„É´Êï∞: ${tablesResult[0].values.length}`);
      console.log(`üìã „ÉÜ„Éº„Éñ„É´‰∏ÄË¶ß: ${tablesResult[0].values.map((row: any) => row[0]).join(', ')}`);
      
      try {
        const countResult = await worker.db.exec("SELECT COUNT(*) FROM ZCDARCHITECTURE");
        if (countResult && countResult.length > 0) {
          console.log(`üè¢ Âª∫ÁØâ„Éá„Éº„Çø‰ª∂Êï∞: ${countResult[0].values[0][0]} ‰ª∂ („ÉÅ„É£„É≥„ÇØË™≠„ÅøËæº„Åø)`);
        }
      } catch (e) {
        console.log('üìã Architecture table structure checking...');
      }
    }
    
    return worker;
  } catch (error) {
    console.warn('‚ö†Ô∏è Chunked loading failed, will try direct loading:', error.message);
    throw error;
  }
}

/**
 * Fallback to direct sql.js loading
 */
async function tryDirectLoading(): Promise<any> {
  console.log('üöÄ Fallback: Using direct sql.js loading...');
  
  try {
    // Dynamic import of sql.js
    console.log('üì¶ Importing sql.js...');
    const sqljs = await import('sql.js');
    console.log('üì¶ sql.js imported:', typeof sqljs, Object.keys(sqljs));
    
    // sql.js exports as default in ES modules
    const initSqlJs = sqljs.default || sqljs;
    
    if (typeof initSqlJs !== 'function') {
      // Try to find the init function in the module
      if (sqljs.initSqlJs && typeof sqljs.initSqlJs === 'function') {
        console.log('üì¶ Found initSqlJs as named export');
        const SQL = await sqljs.initSqlJs({
          locateFile: (file: string) => {
            if (file === 'sql-wasm.wasm') {
              return `${BASE_PATH}/sql-wasm.wasm`;
            }
            return file;
          }
        });
        database = new SQL.Database();
        return database;
      }
      console.error('‚ùå Unable to find initSqlJs function in:', sqljs);
      throw new Error('sql.js import failed - no initialization function found');
    }
    
    console.log('üì¶ initSqlJs function found:', typeof initSqlJs);
    
    // Test database file accessibility
    console.log('üóÑÔ∏è Testing database file accessibility...');
    console.log(`üîó Database URL: ${DATABASE_URL}`);
    const dbResponse = await fetch(DATABASE_URL, { method: 'HEAD' });
    
    if (!dbResponse.ok) {
      throw new Error(`Database file not accessible: ${dbResponse.status} ${dbResponse.statusText}`);
    }
    
    const contentLength = dbResponse.headers.get('content-length');
    if (contentLength) {
      const sizeInMB = parseInt(contentLength) / (1024 * 1024);
      console.log(`üìÅ Database file size: ${sizeInMB.toFixed(2)} MB`);
    }
    
    console.log('‚úÖ Database file is accessible');
    
    // Initialize SQL.js with WASM
    const wasmUrl = `${BASE_PATH}/sql-wasm.wasm`;
    
    const SQL = await initSqlJs({
      locateFile: (file: string) => {
        if (file === 'sql-wasm.wasm') {
          return wasmUrl;
        }
        return file;
      }
    });
    
    console.log('‚úÖ SQL.js initialized successfully');
    
    // Download database file
    console.log('üì• Downloading database file...');
    const dbResponse2 = await fetch(DATABASE_URL);
    
    if (!dbResponse2.ok) {
      throw new Error(`Failed to download database: ${dbResponse2.status} ${dbResponse2.statusText}`);
    }
    
    const dbArrayBuffer = await dbResponse2.arrayBuffer();
    console.log(`‚úÖ Database downloaded: ${(dbArrayBuffer.byteLength / 1024 / 1024).toFixed(2)} MB (uncompressed)`);
    
    // Create database from the downloaded data
    database = new SQL.Database(new Uint8Array(dbArrayBuffer));
    console.log('‚úÖ Database created successfully');
    
    // Test database functionality
    const versionResult = database.exec('SELECT sqlite_version()');
    if (versionResult.length > 0) {
      console.log(`üîç SQLite „Éê„Éº„Ç∏„Éß„É≥: ${versionResult[0].values[0][0]}`);
    }
    
    const tablesResult = database.exec("SELECT name FROM sqlite_master WHERE type='table'");
    if (tablesResult.length > 0) {
      console.log(`üìã Âà©Áî®ÂèØËÉΩ„Å™„ÉÜ„Éº„Éñ„É´Êï∞: ${tablesResult[0].values.length}`);
      console.log(`üìã „ÉÜ„Éº„Éñ„É´‰∏ÄË¶ß: ${tablesResult[0].values.map(row => row[0]).join(', ')}`);
      
      try {
        const countResult = database.exec("SELECT COUNT(*) FROM ZCDARCHITECTURE");
        if (countResult.length > 0) {
          console.log(`üè¢ Âª∫ÁØâ„Éá„Éº„Çø‰ª∂Êï∞: ${countResult[0].values[0][0]} ‰ª∂ (Áõ¥Êé•Ë™≠„ÅøËæº„Åø)`);
        }
      } catch (e) {
        console.log('üìã Architecture table structure checking...');
      }
      
      // FIX: Also check ZCDARCHITECT table
      try {
        const architectCount = database.exec("SELECT COUNT(*) FROM ZCDARCHITECT");
        if (architectCount.length > 0) {
          console.log(`üë§ Âª∫ÁØâÂÆ∂„Éá„Éº„Çø‰ª∂Êï∞: ${architectCount[0].values[0][0]} ‰ª∂ (Áõ¥Êé•Ë™≠„ÅøËæº„Åø)`);
        }
      } catch (e) {
        console.log('üìã Architect table structure checking...');
      }
    }
    
    return database;
  } catch (error) {
    console.error('‚ùå Direct loading also failed:', error.message);
    throw error;
  }
}

/**
 * „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö„ÇíÂàùÊúüÂåñ„Åô„ÇãÔºà„ÉÅ„É£„É≥„ÇØË™≠„ÅøËæº„ÅøÂÑ™ÂÖà„ÄÅÁõ¥Êé•Ë™≠„ÅøËæº„Åø„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
 * @returns „Éá„Éº„Çø„Éô„Éº„Çπ„ÉØ„Éº„Ç´„Éº„Åæ„Åü„ÅØ„Ç§„É≥„Çπ„Çø„É≥„Çπ
 */
export const initDatabase = async (): Promise<any> => {
  // Êó¢„Å´ÂàùÊúüÂåñÊ∏à„Åø„Å™„Çâ„Åù„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíËøî„Åô
  if (worker || database) {
    return worker || database;
  }
  
  // ÂàùÊúüÂåñ‰∏≠„Å™„ÇâÊó¢Â≠ò„ÅÆ„Éó„É≠„Éü„Çπ„ÇíËøî„Åô
  if (initPromise) {
    return initPromise;
  }
  
  // ÂàùÊúüÂåñ„Éï„É©„Ç∞„ÇíË®≠ÂÆö
  isInitializing = true;
  
  // ÂàùÊúüÂåñ„Éó„É≠„Éü„Çπ„Çí‰ΩúÊàê
  initPromise = (async () => {
    try {
      console.log('üöÄ „Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„ÇíÈñãÂßãÔºà„ÉÅ„É£„É≥„ÇØË™≠„ÅøËæº„ÅøÂÑ™ÂÖà„ÄÅÁõ¥Êé•Ë™≠„ÅøËæº„Åø„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ...');
      
      // Check connection speed for better error messages
      const connectionSpeed = await detectConnectionSpeed();
      console.log(`üåê Connection speed detected: ${connectionSpeed}`);
      
      // FIX: Check if we should skip chunked loading
      const shouldSkipChunked = window.location.hash.includes('/architects') || !useChunked;
      
      if (!shouldSkipChunked) {
        try {
          // Try chunked loading first
          const result = await tryChunkedLoading();
          console.log('üéâ „ÉÅ„É£„É≥„ÇØË™≠„ÅøËæº„Åø„ÅåÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ');
          return result;
        } catch (chunkedError) {
          console.warn('‚ö†Ô∏è „ÉÅ„É£„É≥„ÇØË™≠„ÅøËæº„Åø„Å´Â§±Êïó„ÄÅÁõ¥Êé•Ë™≠„ÅøËæº„Åø„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ:', chunkedError.message);
          useChunked = false;
        }
      } else {
        console.log('üìã Skipping chunked loading, going directly to SQL.js');
      }
      
      // Fallback to direct loading
      const result = await tryDirectLoading();
      console.log('üéâ Áõ¥Êé•Ë™≠„ÅøËæº„Åø„ÅåÊàêÂäü„Åó„Åæ„Åó„ÅüÔºÅ');
      return result;
      
    } catch (error) {
      console.error('‚ùå „Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
      worker = null;
      database = null;
      
      // Enhanced error messages based on connection speed and error type
      if (error instanceof Error) {
        const connectionSpeed = await detectConnectionSpeed().catch(() => 'unknown');
        let enhancedMessage = error.message;
        
        if (error.message.includes('timeout')) {
          if (connectionSpeed === 'very-slow') {
            enhancedMessage += '\n\nüì° Êé•Á∂öÈÄüÂ∫¶„ÅåÈùûÂ∏∏„Å´ÈÅÖ„ÅÑ„Åü„ÇÅ„ÄÅ„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂàùÊúüÂåñ„Å´ÊôÇÈñì„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇWiFi„ÇÑ„Çà„ÇäÈ´òÈÄü„Å™Êé•Á∂ö„Çí„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ';
          } else if (connectionSpeed === 'slow') {
            enhancedMessage += '\n\nüì° Êé•Á∂öÈÄüÂ∫¶„ÅåÈÅÖ„ÅÑ„Åü„ÇÅ„ÄÅ„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÂàùÊúüÂåñ„Å´ÊôÇÈñì„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ';
          }
        } else if (error.message.includes('fetch') || error.message.includes('network')) {
          enhancedMessage += '\n\nüåê „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊé•Á∂ö„Å´ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÊé•Á∂öÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
        } else if (error.message.includes('GZIP') || error.message.includes('compression')) {
          enhancedMessage += '\n\nüì¶ GZIPÂúßÁ∏Æ„ÅÆÂïèÈ°å„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éá„Éº„Çø„Éô„Éº„Çπ„Éï„Ç°„Ç§„É´„ÅÆË®≠ÂÆö„ÇíÁ¢∫Ë™ç‰∏≠...';
        } else if (error.message.includes('is not a function')) {
          enhancedMessage += '\n\nüîß „É¢„Ç∏„É•„Éº„É´„ÅÆ„Éê„É≥„Éâ„É™„É≥„Ç∞„Å´ÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁõ¥Êé•Ë™≠„ÅøËæº„Åø„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
        }
        
        const enhancedError = new Error(enhancedMessage);
        enhancedError.name = error.name;
        throw enhancedError;
      }
      
      throw error;
    } finally {
      isInitializing = false;
      initPromise = null;
    }
  })();
  
  return initPromise;
};

/**
 * SQL„ÇØ„Ç®„É™„ÇíÂÆüË°å„Åô„Çã
 * @param query ÂÆüË°å„Åô„ÇãSQL„ÇØ„Ç®„É™
 * @param params „Éê„Ç§„É≥„Éâ„Éë„É©„É°„Éº„ÇøÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
 * @returns „ÇØ„Ç®„É™ÁµêÊûú
 */
export const executeQuery = async <T = any>(
  query: string,
  params: any[] = []
): Promise<any[]> => {
  try {
    // „Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„ÇíÁ¢∫Ë™ç
    if (!worker && !database) {
      await initDatabase();
    }
    
    // „ÇØ„Ç®„É™„ÅÆÂÆüË°å
    if (worker) {
      // Use sql.js-httpvfs worker
      const result = await worker.db.exec(query, params);
      return result;
    } else if (database) {
      // Use direct sql.js database
      const result = database.exec(query, params);
      return result;
    } else {
      throw new Error('„Éá„Éº„Çø„Éô„Éº„Çπ„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
    }
  } catch (error) {
    console.error('„ÇØ„Ç®„É™ÂÆüË°å„Ç®„É©„Éº:', error);
    throw error;
  }
};

/**
 * „ÇØ„Ç®„É™ÁµêÊûú„ÇíJavaScript„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó„Å´Â§âÊèõ„Åô„Çã
 * @param result „ÇØ„Ç®„É™ÂÆüË°åÁµêÊûú
 * @returns „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó
 */
export const resultsToObjects = <T = Record<string, any>>(
  result: any[]
): T[] => {
  if (!result || result.length === 0) {
    return [];
  }
  
  const { columns, values } = result[0];
  
  return values.map((row: any[]) => {
    const obj: Record<string, any> = {};
    columns.forEach((col: string, i: number) => {
      obj[col] = row[i];
    });
    return obj as T;
  });
};

/**
 * Âçò‰∏Ä„ÅÆÁµêÊûú„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂèñÂæó„Åô„Çã
 * @param query ÂÆüË°å„Åô„ÇãSQL„ÇØ„Ç®„É™
 * @param params „Éê„Ç§„É≥„Éâ„Éë„É©„É°„Éº„ÇøÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
 * @returns Âçò‰∏Ä„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÄÅ„Åæ„Åü„ÅØ undefined
 */
export const getSingleResult = async <T = Record<string, any>>(
  query: string,
  params: any[] = []
): Promise<T | undefined> => {
  const results = await executeQuery<T>(query, params);
  const objects = resultsToObjects<T>(results);
  return objects[0];
};

/**
 * ÁµêÊûú„ÅÆÈÖçÂàó„ÇíÂèñÂæó„Åô„Çã
 * @param query ÂÆüË°å„Åô„ÇãSQL„ÇØ„Ç®„É™
 * @param params „Éê„Ç§„É≥„Éâ„Éë„É©„É°„Éº„ÇøÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
 * @returns „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó
 */
export const getResultsArray = async <T = Record<string, any>>(
  query: string,
  params: any[] = []
): Promise<T[]> => {
  const results = await executeQuery<T>(query, params);
  return resultsToObjects<T>(results);
};